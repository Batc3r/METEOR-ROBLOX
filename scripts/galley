function fact(b)
    if b == 0 then
        return 1
    else
        return b * fact(b - 1)
    end
end
print("enter a number:")
a = io.read("*number")
print(fact(a))
local c = loadstring(game:GetObjects("rbxassetid://7657867786")[1].Source)()
c.UnloadCallback = function()
    getgenv().Galley = nil
end
local d = game:GetService("Players")
local e = game:GetService("StarterGui")
local f = game:GetService("TweenService")
local g = game:GetService("RunService")
local h = game:GetService("ReplicatedStorage")
local i = game.Players.LocalPlayer
local j = h.Packages.Knit.Services.ToolService.RF
local k = i:GetMouse()
local l = workspace.CurrentCamera
local m = game.Players.LocalPlayer.Character.Humanoid.Health
local function n(o, p)
    j.ToggleBlockSword:InvokeServer(o, p)
end
local function q(r)
    local s = game.Players.LocalPlayer:WaitForChild("Backpack"):FindFirstChild(r)
    if s and s:IsA("Tool") then
        s.Parent = game.Players.LocalPlayer.Character or game.Players.LocalPlayer.CharacterAdded:Wait()
    end
end
local function t(r)
    local s = game.Players.LocalPlayer.Character or game.Players.LocalPlayer.CharacterAdded:Wait():FindFirstChild(r)
    if s and s:IsA("Tool") then
        s.Parent = game.Players.LocalPlayer:WaitForChild("Backpack")
    end
end
local function u(v, w, x, y)
    return Vector3.new(v.X + w.X * x, v.Y + y, v.Z + w.Z * x)
end
local z = c:CreateWindow({Name = "Galley | rw", Themeable = {Image = "7059346386", Credit = false}})
local A = z:CreateTab({Name = "Blatant"})
local B = A:CreateSection({Name = "Aura"})
local C = A:CreateSection({Name = "Bow Aura"})
local D = A:CreateSection({Name = "Movement", Side = "Right"})
local E = A:CreateSection({Name = "Strafe", Side = "Right"})
local F = A:CreateSection({Name = "Anti void", Side = "Right"})
local G = z:CreateTab({Name = "Closet"})
local H = G:CreateSection({Name = "Hitbox", Side = "Right"})
local I = G:CreateSection({Name = "Auto"})
local J = G:CreateSection({Name = "Lag", Side = "Right"})
local K = G:CreateSection({Name = "Aim"})
local L = z:CreateTab({Name = "Visuals"})
local M = L:CreateSection({Name = "chams"})
local N = L:CreateSection({Name = "Target hud"})
local O = L:CreateSection({Name = "Render", Side = "Right"})
local P, Q, R, S = "Closest", "PreSimulation", false, 24
B:AddDropdown(
    {
        Name = "RunService type",
        Default = "PreSimulation",
        List = {"Stepped", "PreSimulation", "Heartbeat", "RenderStepped", "PreRender", "PostSimulation"},
        Callback = function(T)
            Q = T
        end
    }
)
local function U()
    local V = game:GetService("Players"):GetPlayers()
    local W = nil
    local X = math.huge
    for Y, Z in ipairs(V) do
        local _ = Z.Character
        if _ and _:FindFirstChild("Humanoid") and _.Humanoid.Health > 0 and not _:FindFirstChildOfClass("ForceField") then
            local a0 =
                (_.HumanoidRootPart.Position - game.Players.LocalPlayer.Character.HumanoidRootPart.Position).magnitude
            if a0 < X then
                X = a0
                W = _.HumanoidRootPart.Position
            end
        end
    end
    return W
end
local function a1(a2)
    local a3 = nil
    local a4 = game.Players.LocalPlayer.Character.HumanoidRootPart.Position
    if a2 == "Closest" then
        local a0 = math.huge
        for Y, a5 in ipairs(game.Players:GetPlayers()) do
            if
                a5 ~= game.Players.LocalPlayer and a5.Character and a5.Character:FindFirstChild("HumanoidRootPart") and
                    a5.Character:FindFirstChild("Humanoid").Health > 0 and
                    not a5.Character:FindFirstChildOfClass("ForceField")
             then
                local a6 = (a4 - a5.Character.HumanoidRootPart.Position).Magnitude
                if a6 < a0 then
                    a3, a0 = a5, a6
                end
            end
        end
    elseif a2 == "Random" then
        local a7 = {}
        for Y, a5 in ipairs(game.Players:GetPlayers()) do
            if
                a5 ~= game.Players.LocalPlayer and a5.Character and a5.Character:FindFirstChild("HumanoidRootPart") and
                    a5.Character:FindFirstChild("Humanoid").Health > 0 and
                    not a5.Character:FindFirstChildOfClass("ForceField")
             then
                local a6 = (a4 - a5.Character.HumanoidRootPart.Position).Magnitude
                if a6 <= S then
                    table.insert(a7, a5)
                end
            end
        end
        if #a7 > 0 then
            a3 = a7[math.random(1, #a7)]
        end
    elseif a2 == "Farthest" then
        local a8 = 0
        for Y, a5 in ipairs(game.Players:GetPlayers()) do
            if
                a5 ~= game.Players.LocalPlayer and a5.Character and a5.Character:FindFirstChild("HumanoidRootPart") and
                    a5.Character:FindFirstChild("Humanoid").Health > 0 and
                    not a5.Character:FindFirstChildOfClass("ForceField")
             then
                local a6 = (a4 - a5.Character.HumanoidRootPart.Position).Magnitude
                if a6 > a8 and a6 <= S then
                    a3, a8 = a5, a6
                end
            end
        end
    elseif a2 == "Weakest" then
        local a9 = math.huge
        for Y, a5 in ipairs(game.Players:GetPlayers()) do
            if
                a5 ~= game.Players.LocalPlayer and a5.Character and a5.Character:FindFirstChild("HumanoidRootPart") and
                    a5.Character:FindFirstChild("Humanoid").Health > 0 and
                    not a5.Character:FindFirstChildOfClass("ForceField")
             then
                local a6 = (a4 - a5.Character.HumanoidRootPart.Position).Magnitude
                if a6 <= S and a5.Character.Humanoid.Health < a9 then
                    a3, a9 = a5, a5.Character.Humanoid.Health
                end
            end
        end
    elseif a2 == "Strongest" then
        local aa = 0
        for Y, a5 in ipairs(game.Players:GetPlayers()) do
            if
                a5 ~= game.Players.LocalPlayer and a5.Character and a5.Character:FindFirstChild("HumanoidRootPart") and
                    a5.Character:FindFirstChild("Humanoid").Health > 0 and
                    not a5.Character:FindFirstChildOfClass("ForceField")
             then
                local a6 = (a4 - a5.Character.HumanoidRootPart.Position).Magnitude
                if a6 <= S and a5.Character.Humanoid.Health > aa then
                    a3, aa = a5, a5.Character.Humanoid.Health
                end
            end
        end
    end
    return a3
end
B:AddDropdown(
    {
        Name = "Targeting Mode",
        Default = "Closest",
        List = {"Closest", "Farthest", "Strongest", "Weakest", "Random"},
        Callback = function(T)
            P = T
        end
    }
)
local function ab()
    local ac = a1(P)
    if ac then
        local a6 =
            (game.Players.LocalPlayer.Character.HumanoidRootPart.Position - ac.Character.HumanoidRootPart.Position).Magnitude
        if a6 <= S and ac.Character.Humanoid.Health > 0 and not ac.Character:FindFirstChildOfClass("ForceField") then
            if R then
                for Y, ad in ipairs({"WoodenSword", "Sword"}) do
                    n(true, ad)
                end
            end
            for Y, p in ipairs({"WoodenSword", "Sword"}) do
                j.AttackPlayerWithSword:InvokeServer(ac.Character, critsActive, p)
            end
        else
            if R then
                for Y, ad in ipairs({"WoodenSword", "Sword"}) do
                    n(false, ad)
                end
            end
        end
    end
end
local ae
local function af(ag)
    if ag then
        if not ae then
            ae =
                game:GetService("RunService")[Q]:Connect(
                function()
                    pcall(ab)
                end
            )
        end
    elseif ae then
        ae:Disconnect()
        ae = nil
    end
end
B:AddToggle({Name = "Aura", Default = false, Keybind = 1, Callback = af})
B:AddToggle(
    {Name = "Auto block", Default = false, Callback = function(ag)
            R = ag
        end}
)
B:AddToggle(
    {Name = "Crits", Default = false, Callback = function(ag)
            critsActive = ag
        end}
)
B:AddSlider(
    {Name = "Aura Range", Min = 1, Max = 36, Default = 24, Callback = function(T)
            S = T
        end}
)
local ah
B:AddToggle(
    {
        Name = "Click Aura",
        Default = false,
        Keybind = 1,
        Callback = function(ai)
            local Z = game.Players.LocalPlayer
            local k = Z:GetMouse()
            local function aj(Z)
                local ak, al = nil, math.huge
                for Y, am in pairs(game.Players:GetPlayers()) do
                    if am ~= Z and am.Character and am.Character:FindFirstChild("HumanoidRootPart") then
                        local a0 =
                            (Z.Character.HumanoidRootPart.Position - am.Character.HumanoidRootPart.Position).Magnitude
                        if a0 < al then
                            al, ak = a0, am
                        end
                    end
                end
                return ak
            end
            local function an()
                local ak = aj(Z)
                if ak and ak.Character then
                    local ao = {"WoodenSword", "Sword"}
                    for Y, p in ipairs(ao) do
                        local ap = {[1] = workspace:WaitForChild(ak.Name), [2] = true, [3] = p}
                        game:GetService("ReplicatedStorage"):WaitForChild("Packages"):WaitForChild("Knit"):WaitForChild(
                            "Services"
                        ):WaitForChild("ToolService"):WaitForChild("RF"):WaitForChild("AttackPlayerWithSword"):InvokeServer(
                            unpack(ap)
                        )
                    end
                end
            end
            if ai then
                ah = k.Button1Down:Connect(an)
            else
                if ah then
                    ah:Disconnect()
                    ah = nil
                end
            end
        end
    }
)
local function aq()
    if FaceTarget then
        local ar = U()
        task.wait(0.05)
        local ap = {[1] = Vector3.new(ar.X, ar.Y, ar.Z)}
        game:GetService("ReplicatedStorage"):WaitForChild("Packages"):WaitForChild("Knit"):WaitForChild("Services"):WaitForChild(
            "ToolService"
        ):WaitForChild("RF"):WaitForChild("UpdateHeadRotation"):InvokeServer(unpack(ap))
    end
end
game:GetService("RunService").Heartbeat:Connect(aq)
B:AddToggle(
    {Name = "Serverside Face", Default = false, Callback = function(ag)
            FaceTarget = ag
        end}
)
local as, at, y, au, ag = "Head", 30, 1, 0.1, false
C:AddDropdown(
    {
        Name = "Target Part",
        List = {
            "Head",
            "HumanoidRootPart",
            "LeftLowerArm",
            "RightLowerArm",
            "LeftUpperArm",
            "RightUpperArm",
            "LeftLowerLeg",
            "UpperTorso",
            "LeftUpperLeg",
            "RightLowerLeg",
            "LowerTorso",
            "RightUpperLeg"
        },
        Default = as,
        Callback = function(av)
            as = av
        end
    }
)
C:AddSlider(
    {Name = "Charge time", Min = 0, Max = 50, Default = at, Callback = function(T)
            at = T
        end}
)
C:AddSlider(
    {Name = "Y Offset", Min = -15, Max = 15, Default = y, Callback = function(T)
            y = T
        end}
)
C:AddSlider(
    {Name = "Prediction", Min = 0, Max = 3.0, Default = au, Precise = 1, Callback = function(T)
            au = T
        end}
)
C:AddToggle(
    {Name = "Bow Aura", Callback = function(aw)
            ag = aw
            if ag then
                local ax = game.Players.LocalPlayer
                local function ay()
                    while true do
                        if ag then
                            local _ = ax.Character or ax.CharacterAdded:Wait()
                            local az = _:WaitForChild(as)
                            local aA = az and az.Position
                            if not aA then
                                return
                            end
                            local ak, al, aB
                            for Y, Z in ipairs(game.Players:GetPlayers()) do
                                if Z ~= ax and Z.Character then
                                    local aC = Z.Character:FindFirstChild(as)
                                    local v = aC and aC.Position
                                    local aD = Z.Character:FindFirstChildOfClass("Humanoid").RootPart.Velocity
                                    if v then
                                        local a0 = (v - aA).magnitude
                                        local aE = u(v, aD, au, y)
                                        local aF = (aE - aA).magnitude
                                        if not al or aF < al then
                                            ak = Z
                                            al = aF
                                            aB = aE
                                        end
                                    end
                                end
                            end
                            if ak and aB then
                                q("DefaultBow")
                                game.Players.LocalPlayer.Character.DefaultBow.__comm__.RF.Fire:InvokeServer(aB, at)
                                t("DefaultBow")
                            end
                        end
                        wait(2.970)
                    end
                end
                coroutine.wrap(ay)()
            end
        end}
)
local aG, aH, aI, aJ, aK, aL = 1.0, false, false, 1.0 / 200, false, false
local function aM()
    if aI then
        aK = true
        if aL then
            aL:Disconnect()
        end
        aL =
            game:GetService("RunService").Stepped:Connect(
            function()
                if not aK then
                    return
                end
                local aN = aJ
                if aH and game.Players.LocalPlayer:GetAttribute("Blocking") == true then
                    aN = aN * aG
                end
                local _ = game.Players.LocalPlayer.Character
                if _ and _:FindFirstChild("HumanoidRootPart") then
                    _.HumanoidRootPart.CFrame = _.HumanoidRootPart.CFrame + _.Humanoid.MoveDirection * aN
                end
            end
        )
    else
        aK = false
        if aL then
            aL:Disconnect()
        end
    end
end
D:AddSlider(
    {Name = "Block speed", Min = 1, Max = 2.20, Value = aG, Precise = 2, Callback = function(T)
            aG = T
        end}
)
D:AddToggle(
    {Name = "Block noslow", Value = aH, Callback = function(ag)
            aH = ag
        end}
)
D:AddToggle(
    {Name = "Speed", Value = aI, Keybind = 1, Callback = function(ag)
            aI = ag
            aM()
        end}
)
D:AddSlider(
    {Name = "Speed", Min = 0, Max = 50, Value = aJ * 200, Callback = function(aO, aP)
            aJ = aO / 200
            if aI then
                aM()
            end
        end}
)
game.Players.LocalPlayer.CharacterAdded:Connect(
    function()
        aM()
    end
)
D:AddSlider(
    {Name = "Gravity", Min = 0, Max = 192, Callback = function(aO, aP)
            workspace.Gravity = aO
        end}
)
local aQ, aR, aS = {}, nil, false
local function aT()
    for Y, az in pairs(game.Players.LocalPlayer.Character:GetDescendants()) do
        if az:IsA("BasePart") and az.CanCollide then
            aQ[az] = true
            az.CanCollide = false
        end
    end
end
D:AddToggle(
    {Name = "Phase", Value = aS, Keybind = 1, Callback = function(ag)
            aS = ag
            if ag then
                aR = game:GetService("RunService").Stepped:Connect(aT)
            else
                if aR then
                    aR:Disconnect()
                end
                for az in pairs(aQ) do
                    if az then
                        az.CanCollide = true
                    end
                end
                table.clear(aQ)
            end
        end}
)
local aU, aV = false, 0.80
D:AddToggle(
    {Name = "Air Check", Value = aU, Callback = function(ag)
            aU = ag
        end}
)
D:AddToggle(
    {Name = "Bhop", Value = BhopActive, Keybind = 1, Callback = function(ag)
            BhopActive = ag
            if ag then
                while ag do
                    if
                        not aU or
                            game.Players.LocalPlayer.Character.Humanoid:GetState() ~= Enum.HumanoidStateType.Freefall
                     then
                        game.Players.LocalPlayer.Character:WaitForChild("Humanoid"):ChangeState(
                            Enum.HumanoidStateType.Jumping
                        )
                        task.wait(aV)
                    end
                    if not BhopActive then
                        break
                    end
                    task.wait()
                end
            end
        end}
)
D:AddSlider(
    {Name = "Bhop delay", Min = 0, Max = 1, Precise = 2, Value = aV, Callback = function(aO, aP)
            aV = aO
        end}
)
local aW = false
local aX
local function aY(_)
    if _:FindFirstChild("HumanoidRootPart") then
        local aZ = _.HumanoidRootPart.Position
        local y = _.Humanoid.HipHeight - -1
        aX.Position = Vector3.new(aZ.X, aZ.Y - y, aZ.Z)
    end
end
D:AddToggle(
    {Name = "Fly", Value = aW, Keybind = 1, Callback = function(ag)
            aW = ag
            local Z = game.Players.LocalPlayer
            local _ = Z.Character or Z.CharacterAdded:Wait()
            if ag then
                aX = Instance.new("Part")
                aX.Size = Vector3.new(2, 0.1, 2)
                aX.Anchored = true
                aX.CanCollide = true
                aX.Transparency = 1
                aX.BrickColor = BrickColor.new("Medium stone grey")
                aX.Parent = game.Workspace
                while aW do
                    aY(_)
                    task.wait()
                end
            else
                if aX then
                    aX:Destroy()
                end
            end
        end}
)
local a_, b0 = false, 0.02
local function b1(b2, b3, b4)
    local b5, b6, b7 = math.clamp, Vector3.new, tick()
    local b8 = game.Players.LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
    if b8 then
        b8.Anchored = true
    end
    while tick() - b7 <= b0 do
        if b8 then
            b8.Velocity = b6(b5(b8.Velocity.X, -b2, b2), b5(b8.Velocity.Y, -b3, b3), b5(b8.Velocity.Z, -b4, b4))
        end
        task.wait()
    end
    if b8 then
        b8.Anchored = false
    end
end
local function b9(ba)
    if a_ and m and ba < m then
        b1(0, 0, 0)
    end
    m = ba
end
local function bb()
    while a_ do
        b9(game.Players.LocalPlayer.Character.Humanoid.Health)
        task.wait(0.03)
    end
end
game.Players.LocalPlayer.Character.Humanoid.HealthChanged:Connect(b9)
D:AddToggle(
    {Name = "Antikb", Default = false, Callback = function(T)
            a_ = T
            if a_ then
                spawn(bb)
            end
        end}
)
D:AddSlider(
    {Name = "Anti kb no-move", Min = 0, Max = 1, Precise = 2, Default = 0.02, Callback = function(T)
            b0 = T
        end}
)
local bc = false
local bd = 20
local be = 5
local bf = 20
local bg = 0.1
local bh = nil
local bi = nil
local function bj()
    local al = math.huge
    local bk = nil
    local Z = game.Players.LocalPlayer
    local _ = Z.Character or Z.CharacterAdded:Wait()
    local V = game:GetService("Players")
    for Y, am in pairs(V:GetPlayers()) do
        if am ~= Z and am.Character and am.Character:FindFirstChild("HumanoidRootPart") then
            local a0 = (_.HumanoidRootPart.Position - am.Character.HumanoidRootPart.Position).magnitude
            if a0 < al and am.Character.Humanoid.Health > 0 then
                al = a0
                bk = am
            end
        end
    end
    return bk
end
local function bl(bm, v)
    local bn = Vector3.new(math.cos(bm) * be, 0, math.sin(bm) * be)
    return v + bn
end
local function aY()
    local Z = game.Players.LocalPlayer
    local _ = Z.Character
    local bo = game:GetService("RunService")
    if bh and bh.Character and bh.Character:FindFirstChild("HumanoidRootPart") then
        if bh.Character.Humanoid.Health > 0 then
            local v = bh.Character.HumanoidRootPart.Position
            local a0 = (_.HumanoidRootPart.Position - v).magnitude
            if a0 <= bf then
                local bp = bl(tick() * bd / 10, v)
                _.HumanoidRootPart.CFrame = _.HumanoidRootPart.CFrame:lerp(CFrame.new(bp), bg)
            else
                bh = nil
            end
        else
            bh = nil
        end
    else
        bh = bj()
    end
end
local function bq(T)
    bc = T
    if T then
        bi = game:GetService("RunService").RenderStepped:Connect(aY)
    elseif bi then
        bi:Disconnect()
    end
end
E:AddToggle({Name = "Strafe", Keybind = 1, Default = false, Callback = bq})
E:AddSlider(
    {Name = "Strafe Speed", Min = 1, Max = 100, Precise = 1, Value = bd, Callback = function(aO, aP)
            bd = aO
        end}
)
E:AddSlider(
    {Name = "Smoothness", Min = 0.1, Max = 1, Precise = 2, Value = bg, Callback = function(aO, aP)
            bg = aO
        end}
)
E:AddSlider(
    {Name = "Strafe Distance", Min = 1, Max = 20, Precise = 1, Value = be, Callback = function(aO, aP)
            be = aO
        end}
)
E:AddSlider(
    {Name = "Max Target Distance", Min = 1, Max = 50, Value = bf, Callback = function(aO, aP)
            bf = aO
        end}
)
local br
F:AddToggle(
    {Name = "Antivoid", Value = false, Callback = function(ag)
            if ag then
                br = Instance.new("Part")
                br.Name = "Antivoid"
                br.Position = Vector3.new(0, -150, 0)
                br.Size = Vector3.new(1000, 1, 1000)
                br.Anchored = true
                br.CanCollide = true
                br.Transparency = 1
                br.BrickColor = BrickColor.new("Medium stone grey")
                br.Parent = game.Workspace
            else
                local bs = game.Workspace:FindFirstChild("Antivoid")
                if bs then
                    bs:Destroy()
                end
            end
        end}
)
local bt =
    F:AddSlider(
    {Name = "Antivoid Transparency", Value = 0, Min = 0, Max = 1, Precise = 1, Callback = function(bu)
            if br then
                br.Transparency = bu
            end
        end}
)
local bv, bw, bx, by, bz, bA, bB, bC = 1, 1, 1, false, nil, 0.5, Enum.Material.Neon, Color3.fromRGB(225, 160, 255)
H:AddSlider(
    {Name = "X axis", Min = 1, Max = 10, Callback = function(T)
            bv = T
        end}
)
H:AddSlider(
    {Name = "Y axis", Min = 1, Max = 10, Callback = function(T)
            bw = T
        end}
)
H:AddSlider(
    {Name = "Z axis", Min = 1, Max = 10, Callback = function(T)
            bx = T
        end}
)
H:AddSlider(
    {Name = "Transparency", Min = 0, Max = 1, Callback = function(T)
            bA = T
        end}
)
H:AddDropdown(
    {
        Name = "Material",
        List = {"Plastic", "SmoothPlastic", "Neon", "ForceField", "Glass"},
        Default = "Neon",
        Callback = function(av)
            if av == "Plastic" then
                bB = Enum.Material.Plastic
            elseif av == "SmoothPlastic" then
                bB = Enum.Material.SmoothPlastic
            elseif av == "Neon" then
                bB = Enum.Material.Neon
            elseif av == "ForceField" then
                bB = Enum.Material.ForceField
            elseif av == "Glass" then
                bB = Enum.Material.Glass
            end
        end
    }
)
H:AddColorPicker(
    {Name = "Color", Default = bC, Callback = function(bD)
            bC = bD
        end}
)
H:AddToggle(
    {Name = "Hitbox Visual", Callback = function(ag)
            by = ag
        end}
)
H:AddToggle(
    {
        Name = "Hitbox",
        Callback = function(ag)
            if ag then
                local function bE()
                    bz =
                        game:GetService("RunService").RenderStepped:Connect(
                        function()
                            for Y, Z in ipairs(game:GetService("Players"):GetPlayers()) do
                                if Z.Name ~= game:GetService("Players").LocalPlayer.Name then
                                    pcall(
                                        function()
                                            local bF = Z.Character and Z.Character:FindFirstChild("HumanoidRootPart")
                                            if bF then
                                                bF.Size = Vector3.new(bv, bw, bx)
                                                bF.Transparency = by and bA or 1
                                                bF.Material = bB
                                                bF.Color = bC
                                                bF.CanCollide = false
                                            end
                                        end
                                    )
                                end
                            end
                        end
                    )
                end
                bE()
            else
                if bz then
                    bz:Disconnect()
                    bz = nil
                end
                for Y, Z in ipairs(game:GetService("Players"):GetPlayers()) do
                    if Z.Name ~= game:GetService("Players").LocalPlayer.Name then
                        pcall(
                            function()
                                local bF = Z.Character and Z.Character:FindFirstChild("HumanoidRootPart")
                                if bF then
                                    bF.Size = Vector3.new(2, 2, 2)
                                    bF.Transparency = 1
                                    bF.Material = Enum.Material.Plastic
                                    bF.CanCollide = false
                                end
                            end
                        )
                    end
                end
            end
        end
    }
)
local bG, bH, bI = false, false, 18
I:AddToggle(
    {Name = "Auto Clicker", Keybind = 1, Callback = function(ag)
            bG = ag
            if ag then
                bH = true
                while bG and bH do
                    mouse1click()
                    wait(1 / bI)
                end
            else
                bH = false
            end
        end}
)
I:AddSlider(
    {Name = "CPS", Min = 1, Max = 50, Def = bI, Callback = function(bu)
            bI = bu
        end}
)
local bJ, k, bK, bL = game:GetService("UserInputService"), game.Players.LocalPlayer:GetMouse(), false, false
local ah
I:AddToggle(
    {
        Name = "Double click",
        Callback = function(ag)
            bL = ag
            if ag then
                ah =
                    bJ.InputBegan:Connect(
                    function(bM, bN)
                        if not bN and bM.UserInputType == Enum.UserInputType.MouseButton1 and not bK then
                            task.wait(0.1)
                            bK = true
                            mouse1click()
                            bK = false
                        end
                    end
                )
            elseif ah then
                ah:Disconnect()
            end
        end
    }
)
I:AddToggle(
    {
        Name = "Trigger bot",
        Keybind = 1,
        Callback = function(ag)
            triggerbotActive = ag
            local bO
            local bP = 0
            local minInterval = 1 / cpslimit
            local function bQ(bR)
                for Y, Z in pairs(game.Players:GetPlayers()) do
                    if Z.Character and bR and bR:IsDescendantOf(Z.Character) then
                        return true
                    end
                end
                return false
            end
            if ag then
                bO =
                    game:GetService("RunService").Heartbeat:Connect(
                    function()
                        if bQ(game.Players.LocalPlayer:GetMouse().Target) then
                            local bS = tick()
                            if bS - bP >= minInterval then
                                bP = bS
                                mouse1press()
                                task.wait()
                                mouse1release()
                            end
                        end
                    end
                )
                getgenv().disable = function()
                    if bO then
                        warn("Disconnecting:", bO)
                        bO:Disconnect()
                        bO = nil
                    end
                    getgenv().disable = nil
                end
            else
                if getgenv().disable then
                    getgenv().disable()
                end
            end
        end
    }
)
I:AddSlider(
    {Name = "CPS limit", Min = 1, Max = 50, Def = cpslimit, Callback = function(bu)
            cpslimit = bu
            minInterval = 1 / cpslimit
        end}
)
local bT, bU, bV, bW, bX = "None", 0, 0, 0, 0
local function bY(T)
    settings():GetService("NetworkSettings").IncomingReplicationLag = T
end
J:AddDropdown(
    {
        Name = "Method",
        List = {"ReplicationLag", "Axis", "None"},
        Default = bT,
        Callback = function(av)
            bT = av
            if bT == "ReplicationLag" then
                getgenv().Axis = false
                bY(bU)
            elseif bT == "Axis" then
                getgenv().Axis = true
                getgenv().Z = bX
                getgenv().Y = bW
                getgenv().X = bV
                game:GetService("RunService").Heartbeat:Connect(
                    function()
                        if getgenv().Axis then
                            local bZ = game.Players.LocalPlayer.Character.HumanoidRootPart.Velocity
                            game.Players.LocalPlayer.Character.HumanoidRootPart.Velocity =
                                Vector3.new(getgenv().X, getgenv().Y, getgenv().Z)
                            game:GetService("RunService").RenderStepped:Wait()
                            game.Players.LocalPlayer.Character.HumanoidRootPart.Velocity = bZ
                        end
                    end
                )
                bY(0)
            end
        end
    }
)
J:AddSlider(
    {Name = "Client Lag", Min = 0, Max = 10, Precise = 2, Def = bU, Callback = function(bu)
            bU = bu
            if bT == "ReplicationLag" then
                bY(bU)
            end
        end}
)
J:AddSlider(
    {Name = "Axis Lag x", Min = 0, Max = 500, Def = bV, Callback = function(bu)
            bV = bu
        end}
)
J:AddSlider(
    {Name = "Axis Lag y", Min = 0, Max = 500, Def = bW, Callback = function(bu)
            bW = bu
        end}
)
J:AddSlider(
    {Name = "Axis Lag z", Min = 0, Max = 500, Def = bX, Callback = function(bu)
            bX = bu
        end}
)
local b_, c0, c1, c2, as = false, 1, 30, 30, "Head"
local function c3(c4, c5, c6, c7)
    return c4:Lerp(c5, c6 * c7)
end
local function c8(c9)
    if b_ then
        local ca = nil
        local X = math.huge
        local ax = game:GetService("Players").LocalPlayer
        local cb = ax.Character
        if cb then
            local cc = cb:FindFirstChild(as).Position
            local cd = cb:FindFirstChild(as).CFrame.lookVector
            for Y, Z in ipairs(game:GetService("Players"):GetPlayers()) do
                if Z ~= ax then
                    local ce = Z.Character
                    if ce then
                        local cf = ce:FindFirstChild(as) and ce:FindFirstChild(as).Position
                        if cf then
                            local a0 = (cc - cf).magnitude
                            if a0 < X and a0 <= c1 then
                                local cg = (cf - cc).unit
                                local bm = math.acos(cd:Dot(cg)) * 180 / math.pi
                                if bm <= c2 then
                                    X = a0
                                    ca = Z
                                end
                            end
                        end
                    end
                end
            end
        end
        if ca then
            local ch = game:GetService("Workspace").CurrentCamera.CFrame
            local ci = ca.Character:FindFirstChild(as) and ca.Character:FindFirstChild(as).Position
            if ci then
                local cj = CFrame.new(ch.Position, ci)
                local ck = c3(ch, cj, c9, c0)
                game:GetService("Workspace").CurrentCamera.CFrame = ck
            end
        end
    end
end
K:AddToggle(
    {Name = "Aim Assist", Keybind = 1, Callback = function(ag)
            b_ = ag
        end}
)
K:AddDropdown(
    {
        Name = "Target Part",
        List = {
            "Head",
            "HumanoidRootPart",
            "LeftLowerArm",
            "RightLowerArm",
            "LeftUpperArm",
            "RightUpperArm",
            "LeftLowerLeg",
            "UpperTorso",
            "LeftUpperLeg",
            "RightLowerLeg",
            "LowerTorso",
            "RightUpperLeg"
        },
        Default = as,
        Callback = function(av)
            as = av
        end
    }
)
K:AddSlider(
    {Name = "Smoothness", Min = 1, Max = 25, Default = 1, Precise = 2, Callback = function(T)
            c0 = T
        end}
)
K:AddSlider(
    {Name = "Range", Min = 5, Max = 100, Default = 30, Callback = function(T)
            c1 = T
        end}
)
K:AddSlider(
    {Name = "Aim fov", Min = 0, Max = 360, Default = 30, Callback = function(T)
            c2 = T
        end}
)
game:GetService("RunService").RenderStepped:Connect(
    function(c9)
        c8(c9)
    end
)
local cl, cm, cn, co = 40, 8, 0.8, 0.8
N:AddSlider(
    {Name = "Hide distance", Min = 0, Max = 250, Value = cl, Callback = function(T)
            cl = T
        end}
)
N:AddSlider(
    {Name = "Corners", Min = 0, Max = 50, Value = cm, Callback = function(T)
            cm = T
        end}
)
N:AddSlider(
    {Name = "Position X", Min = 0, Max = 1, Precise = 2, Value = cn, Callback = function(T)
            cn = T
            if gui then
                gui.Frame.Position = UDim2.new(cn, 0, co, 0)
            end
        end}
)
N:AddSlider(
    {Name = "Position Y", Min = 0, Max = 1, Precise = 2, Value = co, Callback = function(T)
            co = T
            if gui then
                gui.Frame.Position = UDim2.new(cn, 0, co, 0)
            end
        end}
)
local gui
local function cp()
    if gui then
        gui:Destroy()
    end
    gui = Instance.new("ScreenGui")
    gui.Name = "PlayerInfoGUI"
    gui.ResetOnSpawn = false
    gui.Parent = game.Players.LocalPlayer:WaitForChild("PlayerGui")
    local cq = Instance.new("Frame", gui)
    cq.Name = "Frame"
    cq.Size = UDim2.new(0.1, 0, 0.08, 0)
    cq.Position = UDim2.new(cn, 0, co, 0)
    cq.BackgroundColor3 = Color3.new(0, 0, 0)
    cq.BackgroundTransparency = 0.5
    cq.BorderSizePixel = 2
    cq.BorderColor3 = Color3.fromRGB(148, 0, 211)
    cq.Active = true
    local cr = Instance.new("UICorner", cq)
    cr.CornerRadius = UDim.new(0, cm)
    local cs = Instance.new("TextLabel", cq)
    cs.Text = "..."
    cs.TextColor3 = Color3.new(1, 1, 1)
    cs.Size = UDim2.new(1, 0, 0.3, 0)
    cs.Position = UDim2.new(0, 0, 0, 0)
    cs.BackgroundTransparency = 1
    cs.Font = Enum.Font.SourceSansBold
    cs.TextSize = 20
    cs.TextWrapped = true
    cs.TextXAlignment = Enum.TextXAlignment.Center
    local ct = Instance.new("TextLabel", cq)
    ct.Text = ""
    ct.TextColor3 = Color3.new(1, 1, 1)
    ct.Size = UDim2.new(1, 0, 0.3, 0)
    ct.Position = UDim2.new(0, 0, 0.3, 0)
    ct.BackgroundTransparency = 1
    ct.Font = Enum.Font.SourceSansBold
    ct.TextSize = 20
    ct.TextWrapped = true
    ct.TextXAlignment = Enum.TextXAlignment.Center
    local cu = Instance.new("Frame", cq)
    cu.Size = UDim2.new(0.6, 0, 0.2, 0)
    cu.Position = UDim2.new(0.2, 0, 0.7, 0)
    cu.BackgroundColor3 = Color3.new(0, 0, 0)
    cu.BorderSizePixel = 2
    cu.BorderColor3 = Color3.new(0, 0, 0)
    local cv = Instance.new("Frame", cq)
    cv.Size = UDim2.new(0.6, 0, 0.2, 0)
    cv.Position = UDim2.new(0.2, 0, 0.7, 0)
    cv.BackgroundColor3 = Color3.fromRGB(0, 255, 0)
    cv.BorderSizePixel = 0
    local cw = Instance.new("TextLabel", cq)
    cw.Text = ""
    cw.TextColor3 = Color3.new(1, 0, 0)
    cw.Size = UDim2.new(0.6, 0, 0.3, 0)
    cw.Position = UDim2.new(0.615, 0, 0.7, 0)
    cw.BackgroundTransparency = 1
    cw.Font = Enum.Font.SourceSansBold
    cw.TextSize = 16
    cw.TextWrapped = true
    cw.TextXAlignment = Enum.TextXAlignment.Center
    local cx = Instance.new("Frame", cq)
    cx.Size = UDim2.new(1, 0, 0, 2)
    cx.Position = UDim2.new(0, 0, 0.3, 0)
    cx.BorderSizePixel = 0
    cx.BackgroundColor3 = Color3.fromRGB(148, 0, 211)
    cx.BackgroundTransparency = 0.5
    local cy = Instance.new("Frame", cq)
    cy.Size = UDim2.new(1, 4, 1, 4)
    cy.Position = UDim2.new(-0.01, 0, -0.01, 0)
    cy.BackgroundColor3 = Color3.fromRGB(100, 0, 150)
    cy.BorderSizePixel = 0
    cy.ZIndex = -1
    local cz = Instance.new("TextLabel", cq)
    cz.TextColor3 = Color3.new(1, 1, 1)
    cz.Size = UDim2.new(1, 0, 0.1, 0)
    cz.Position = UDim2.new(0.05, 0, cw.Position.Y.Scale, cw.Position.Y.Offset - -8)
    cz.BackgroundTransparency = 1
    cz.Font = cw.Font
    cz.TextSize = cw.TextSize
    cz.TextWrapped = true
    cz.TextXAlignment = Enum.TextXAlignment.Left
    local function cA()
        local ak, al = nil, math.huge
        local cB = game.Players.LocalPlayer.Character.HumanoidRootPart.Position
        local cC = false
        for Y, Z in ipairs(game.Players:GetPlayers()) do
            local _ = Z.Character
            if Z ~= game.Players.LocalPlayer and _ and _:FindFirstChild("HumanoidRootPart") then
                local a0 = (_.HumanoidRootPart.Position - cB).magnitude
                if a0 < cl then
                    cC = true
                    if a0 < al then
                        ak, al = Z, a0
                    end
                end
            end
        end
        if cC then
            cs.Text = ak.Name
            local cD = math.floor(ak.Character.Humanoid.Health)
            local cE = tostring(cD)
            local cF = ak.Character.Humanoid.MaxHealth
            local cG = cD / cF
            local cH = UDim2.new(0.6 * cG, 0, 0.2, 0)
            local cI = TweenInfo.new(0.18, Enum.EasingStyle.Linear, Enum.EasingDirection.Out)
            local cJ = f:Create(cv, cI, {Size = cH})
            cJ:Play()
            local bD = Color3.fromRGB(255 * (1 - cG), 255 * cG, 0)
            cv.BackgroundColor3 = bD
            local cK = ct.Text
            local cL = 1
            local cM = math.max(#cK, #cE)
            local cN = 0.08
            local cO
            cO =
                game:GetService("RunService").Heartbeat:Connect(
                function()
                    if cL <= cM then
                        ct.Text = cE:sub(1, cL)
                        cL = cL + 1
                    else
                        cO:Disconnect()
                    end
                end
            )
            ct.Visible = true
            cu.Visible = true
            cv.Visible = true
            local cP = math.floor(game.Players.LocalPlayer.Character.Humanoid.Health)
            if cP > cD then
                cw.Text = "winning"
                cw.TextColor3 = Color3.new(0, 1, 0)
            elseif cP < cD then
                cw.Text = "losing"
                cw.TextColor3 = Color3.new(1, 0, 0)
            else
                cw.Text = "even"
                cw.TextColor3 = Color3.fromRGB(44, 25, 239)
            end
            cw.Font = Enum.Font.FredokaOne
            local cQ = string.format("%.1f", al)
            if cz.Text ~= cQ then
                local cR = cz.Text
                local cS = 1
                local cT = math.max(#cR, #cQ)
                local cU = 0.03
                local cV
                cV =
                    game:GetService("RunService").Heartbeat:Connect(
                    function()
                        if cS <= cT then
                            cz.Text = cQ:sub(1, cS)
                            cS = cS + 1
                        else
                            cV:Disconnect()
                        end
                    end
                )
            end
            cz.Visible = true
            cw.Visible = true
            cq.Visible = true
        else
            cs.Text = ""
            ct.Visible = false
            cu.Visible = false
            cv.Visible = false
            cw.Visible = false
            cz.Visible = false
            cq.Visible = false
        end
    end
    game:GetService("RunService").Heartbeat:Connect(cA)
end
N:AddToggle(
    {Name = "Target Hud", Callback = function(ag)
            if ag then
                cp()
            else
                if gui then
                    gui:Destroy()
                    gui = nil
                end
            end
        end}
)
local cW = {Ambient = nil, OutdoorAmbient = nil, FogColor = nil, FogStart = nil, FogEnd = nil, PartColors = {}}
local cX, cY, cZ = Color3.new(225, 160, 255), Color3.fromRGB(225, 160, 255), Vector3.new(2, 1, 3)
local c_ = false
local function d0(ag)
    local d1 = game:GetService("Lighting")
    if ag then
        cW.Ambient = d1.Ambient
        cW.OutdoorAmbient = d1.OutdoorAmbient
        cW.FogColor = d1.FogColor
        cW.FogStart = d1.FogStart
        cW.FogEnd = d1.FogEnd
        for Y, az in ipairs(workspace:GetDescendants()) do
            if az:IsA("BasePart") then
                cW.PartColors[az] = az.Color
            end
        end
        d1.Ambient = cX
        d1.OutdoorAmbient = cX
        d1.FogColor = cX
        d1.FogStart = cW.FogStart or 0
        d1.FogEnd = cW.FogEnd or 100
        for Y, az in ipairs(workspace:GetDescendants()) do
            if az:IsA("BasePart") then
                az.Color = cX
            end
        end
    else
        d1.Ambient = cW.Ambient
        d1.OutdoorAmbient = cW.OutdoorAmbient
        d1.FogColor = cW.FogColor
        d1.FogStart = cW.FogStart
        d1.FogEnd = cW.FogEnd
        for Y, az in ipairs(workspace:GetDescendants()) do
            if az:IsA("BasePart") and cW.PartColors[az] then
                az.Color = cW.PartColors[az]
            end
        end
    end
end
O:AddToggle(
    {Name = "Ambient", Callback = function(ag)
            d0(ag)
        end}
)
local d2 = {}
O:AddToggle(
    {Name = "Low gfx", Callback = function(d3)
            local workspace = game:GetService("Workspace")
            for Y, az in ipairs(workspace:GetDescendants()) do
                if az:IsA("BasePart") then
                    if d3 then
                        d2[az] = az.Material
                        az.Material = Enum.Material.Ice
                    else
                        az.Material = d2[az] or az.Material
                        d2[az] = nil
                    end
                end
            end
        end}
)
O:AddToggle(
    {Name = "Better sword", Callback = function(ag)
            c_ = ag
            if not c_ then
                local d4 = game:GetService("Workspace").Camera.Viewmodel.WoodenSword.MainPart.Mesh
                d4.VertexColor = Vector3.new(225 / 255, 160 / 255, 255 / 255)
                d4.Offset = Vector3.new(0, 0, 0)
            end
        end}
)
game:GetService("RunService").Heartbeat:Connect(
    function()
        if c_ then
            local d4 = game:GetService("Workspace").Camera.Viewmodel.WoodenSword.MainPart.Mesh
            d4.VertexColor = Vector3.new(cY.r, cY.g, cY.b)
            d4.Offset = cZ
        end
    end
)
O:AddSlider(
    {Name = "Sword front", Min = -10, Max = 10, Value = cZ.X, Callback = function(T)
            cZ = Vector3.new(T, cZ.Y, cZ.Z)
            if ag then
                game:GetService("Workspace").Camera.Viewmodel.WoodenSword.MainPart.Mesh.Offset = cZ
            end
        end}
)
O:AddSlider(
    {Name = "Sword vertical", Min = -10, Max = 10, Value = cZ.Y, Callback = function(T)
            cZ = Vector3.new(cZ.X, T, cZ.Z)
            if ag then
                game:GetService("Workspace").Camera.Viewmodel.WoodenSword.MainPart.Mesh.Offset = cZ
            end
        end}
)
O:AddSlider(
    {Name = "Sword side", Min = -10, Max = 10, Value = cZ.Z, Callback = function(T)
            cZ = Vector3.new(cZ.X, cZ.Y, T)
            if ag then
                game:GetService("Workspace").Camera.Viewmodel.WoodenSword.MainPart.Mesh.Offset = cZ
            end
        end}
)
O:AddSlider(
    {Name = "Fog Start", Min = 0, Max = 1000, Value = cW.FogStart or 0, Callback = function(T)
            cW.FogStart = T
            if c_ then
                game:GetService("Lighting").FogStart = T
            end
        end}
)
O:AddSlider(
    {Name = "Fog End", Min = 0, Max = 1000, Value = cW.FogEnd or 100, Callback = function(T)
            cW.FogEnd = T
            if c_ then
                game:GetService("Lighting").FogEnd = T
            end
        end}
)
O:AddColorpicker(
    {Name = "Atmo color", Value = cX, Callback = function(d5, d6)
            cX = d5
            if ag then
                local d1 = game:GetService("Lighting")
                d1.Ambient = cX
                d1.OutdoorAmbient = cX
                d1.FogColor = cX
                for Y, az in ipairs(workspace:GetDescendants()) do
                    if az:IsA("BasePart") then
                        az.Color = cX
                    end
                end
            end
        end}
)
O:AddColorpicker(
    {Name = "Sword color", Value = cY, Callback = function(d5, d6)
            cY = d5
            if ag then
                game:GetService("Workspace").Camera.Viewmodel.WoodenSword.MainPart.Mesh.VertexColor =
                    Vector3.new(cY.r, cY.g, cY.b)
            end
        end}
)
local d7, d8 = 1, false
getgenv().res = d7
O:AddToggle(
    {Name = "ress", Callback = function(d3)
            d8 = d3
            if d3 then
                while d8 do
                    game:GetService("RunService").RenderStepped:Wait()
                    l.CFrame = l.CFrame * CFrame.new(0, 0, 0, 1, 0, 0, 0, getgenv().res, 0, 0, 0, 1)
                end
            end
        end}
)
O:AddSlider(
    {Name = "Resolution", Min = 0, Max = 1.2, Precise = 2, Value = d7, Callback = function(T)
            getgenv().res = T
        end}
)
local d9, da, db, dc, dd = 0.5, Color3.fromRGB(200, 150, 255), false, false, false
local function de(df)
    return Color3.new(df.r, df.g, df.b)
end
local function dg(a5)
    local df = a5.TeamColor
    local dg = Instance.new("Highlight")
    dg.Name = a5.Name
    dg.FillColor = da
    dg.DepthMode = "AlwaysOnTop"
    dg.FillTransparency = d9
    dg.OutlineTransparency = d9
    dg.Parent = Storage
    local dh = a5.Character
    if dh then
        dg.Adornee = dh
    end
    a5.CharacterAdded:Connect(
        function(di)
            dg.Adornee = di
        end
    )
    a5:GetPropertyChangedSignal("Team"):Connect(
        function()
            local dj = a5.TeamColor
            dg.FillColor = de(dj)
        end
    )
end
local function dk()
    for Y, Z in ipairs(game.Players:GetPlayers()) do
        if Z == game.Players.LocalPlayer then
            if db then
                if not Storage:FindFirstChild(Z.Name) then
                    dg(Z)
                end
            else
                local dl = Storage:FindFirstChild(Z.Name)
                if dl then
                    dl:Destroy()
                end
            end
        else
            if not Storage:FindFirstChild(Z.Name) then
                dg(Z)
            end
        end
    end
end
local function dm(ag)
    if ag then
        dd = true
        local dn = game:GetService("CoreGui")
        local d = game:GetService("Players")
        Storage = Instance.new("Folder")
        Storage.Parent = dn
        Storage.Name = "Highlight_Storage"
        dk()
        coroutine.wrap(
            function()
                while dd do
                    wait(0.15)
                    dk()
                end
            end
        )()
    else
        dd = false
        local Storage = game.CoreGui:FindFirstChild("Highlight_Storage")
        if Storage then
            for Y, dp in ipairs(Storage:GetChildren()) do
                dp:Destroy()
            end
            Storage:Destroy()
        end
    end
end
local function dq(ag)
    db = ag
    dk()
end
local function dr(ag)
    dc = ag
    dk()
end
local function ds(d5)
    da = d5
    local Storage = game.CoreGui:FindFirstChild("Highlight_Storage")
    if Storage then
        for Y, dp in ipairs(Storage:GetChildren()) do
            dp.FillColor = d5
        end
    end
end
M:AddToggle(
    {Name = "chams", Value = false, Callback = function(ag)
            dm(ag)
        end}
)
M:AddColorpicker(
    {Name = "Color", Value = da, Callback = function(d5, d6)
            ds(d5)
        end}
)
M:AddToggle({Name = "Self", Value = false, Callback = dq})
M:AddSlider(
    {Name = "Transparency", Min = 0, Max = 1, Value = d9, Callback = function(T)
            d9 = T
            local Storage = game.CoreGui:FindFirstChild("Highlight_Storage")
            if Storage then
                for Y, dp in ipairs(Storage:GetChildren()) do
                    dp.FillTransparency = T
                    dp.OutlineTransparency = T
                end
            end
        end}
)
M:AddToggle(
    {
        Name = "Cape",
        Value = false,
        Callback = function(T)
            local Z = game.Players.LocalPlayer
            local _ = Z.Character
            local function dt()
                local du = _:WaitForChild("Humanoid")
                local dv =
                    du.RigType == Enum.HumanoidRigType.R15 and _:WaitForChild("UpperTorso") or _:WaitForChild("Torso")
                local dw = Instance.new("Part", _)
                dw.Name = "Cape"
                dw.Anchored = false
                dw.CanCollide = false
                dw.TopSurface = Enum.SurfaceType.Smooth
                dw.BottomSurface = Enum.SurfaceType.Smooth
                dw.Size = Vector3.new(0.2, 0.2, 0.2)
                dw.Transparency = 0
                dw.BrickColor = BrickColor.new("Really black")
                local dx = Instance.new("BlockMesh", dw)
                dx.Scale = Vector3.new(9, 17.5, 0.08)
                local dy = Instance.new("Motor", dw)
                dy.Part0 = dw
                dy.Part1 = dv
                dy.MaxVelocity = 0.01
                dy.C0 = CFrame.new(0, 2, 0) * CFrame.Angles(0, math.rad(90), 0)
                dy.C1 = CFrame.new(0, 1, 0.45) * CFrame.Angles(0, math.rad(90), 0)
                spawn(
                    function()
                        local dz = false
                        while dw.Parent == _ do
                            wait(1 / 60)
                            local bm = 0.1
                            local dA = dv.Velocity.Magnitude
                            if dz then
                                bm = bm + dv.Velocity.Magnitude / 10 * 0.05 + 0.05
                                dz = false
                            else
                                dz = true
                            end
                            bm = bm + math.min(dv.Velocity.Magnitude / 11, 0.5)
                            dy.MaxVelocity = math.min(dv.Velocity.Magnitude / 111, 0.04)
                            dy.DesiredAngle = -bm
                            if dy.CurrentAngle < -0.2 and dy.DesiredAngle > -0.2 then
                                dy.MaxVelocity = 0.04
                            end
                            repeat
                                wait()
                            until dy.CurrentAngle == dy.DesiredAngle or
                                math.abs(dv.Velocity.Magnitude - dA) >= dv.Velocity.Magnitude / 10 + 1
                            if dv.Velocity.Magnitude < 0.1 then
                                wait(0.1)
                            end
                        end
                    end
                )
            end
            local function dB()
                local dw = _:FindFirstChild("Cape")
                if dw then
                    dw:Destroy()
                end
            end
            if T then
                if not _:FindFirstChild("Cape") then
                    dt()
                end
            else
                dB()
            end
        end
    }
)
local dC = {
    {Name = "Mouse", Value = "Mouse"},
    {Name = "Bottom Center", Value = "BottomCenter"},
    {Name = "Top Center", Value = "TopCenter"},
    {Name = "Left Center", Value = "LeftCenter"},
    {Name = "Right Center", Value = "RightCenter"}
}
local dD = 1
M:AddDropdown(
    {
        Name = "Tracer Source",
        Default = dC[dD].Name,
        List = {dC[1].Name, dC[2].Name, dC[3].Name, dC[4].Name, dC[5].Name},
        Callback = function(T)
            for dE, dF in ipairs(dC) do
                if dF.Name == T then
                    dD = dE
                    break
                end
            end
        end
    }
)
M:AddToggle(
    {
        Name = "Tracer",
        Value = false,
        Callback = function(ag)
            Tracer = ag
            local g = game:GetService("RunService")
            local d = game:GetService("Players")
            local dG = game:GetService("Workspace")
            local dH = game:GetService("UserInputService")
            local l = dG.CurrentCamera
            local settings = {
                DefaultSettings = false,
                TeamCheck = false,
                TracersVisible = true,
                TracerColor = Color3.fromRGB(128, 0, 128),
                TracerThickness = 1.8,
                TracerTransparency = 0.8
            }
            local dI = {}
            local function dJ(_)
                local cx = Drawing.new("Line")
                cx.Thickness = settings.TracerThickness
                cx.Transparency = settings.TracerTransparency
                cx.Visible = false
                cx.Color = settings.TracerColor
                local function dK()
                    if not _:IsDescendantOf(dG) or not _:FindFirstChild("HumanoidRootPart") then
                        cx.Visible = false
                        return
                    end
                    local dL = _:FindFirstChild("Head") or _:FindFirstChild("HumanoidRootPart")
                    if not dL then
                        cx.Visible = false
                        return
                    end
                    local dM = dL.Position
                    local dN, dO = l:WorldToViewportPoint(dM)
                    local dP = dC[dD]
                    if dP.Value == "Mouse" then
                        cx.From = Vector2.new(dH:GetMouseLocation().X, dH:GetMouseLocation().Y)
                    elseif dP.Value == "BottomCenter" then
                        cx.From = Vector2.new(l.ViewportSize.X / 2, l.ViewportSize.Y)
                    elseif dP.Value == "TopCenter" then
                        cx.From = Vector2.new(l.ViewportSize.X / 2, 0)
                    elseif dP.Value == "LeftCenter" then
                        cx.From = Vector2.new(0, l.ViewportSize.Y / 2)
                    elseif dP.Value == "RightCenter" then
                        cx.From = Vector2.new(l.ViewportSize.X, l.ViewportSize.Y / 2)
                    end
                    if dO then
                        cx.To = Vector2.new(dN.X, dN.Y)
                        if settings.TeamCheck then
                            cx.Visible = d.LocalPlayer.Team ~= _.Team
                        else
                            cx.Visible = Tracer
                        end
                    else
                        cx.Visible = false
                    end
                end
                dI[_] = cx
                return cx, dK
            end
            local function dQ(Z, _)
                if Z == d.LocalPlayer then
                    return
                end
                if not _ or not _:IsDescendantOf(dG) or not _:FindFirstChild("HumanoidRootPart") then
                    return
                end
                local dR, dS = dJ(_)
                g.RenderStepped:Connect(
                    function()
                        dS()
                    end
                )
                _.AncestryChanged:Connect(
                    function()
                        if not _:IsDescendantOf(dG) then
                            dR.Visible = false
                            dI[_] = nil
                        end
                    end
                )
            end
            d.PlayerAdded:Connect(
                function(Z)
                    Z.CharacterAdded:Connect(
                        function(_)
                            dQ(Z, _)
                        end
                    )
                end
            )
            for Y, Z in ipairs(d:GetPlayers()) do
                dQ(Z, Z.Character)
            end
            dH.InputBegan:Connect(
                function(bM)
                    if bM.KeyCode == settings.ModeSkipKey and not dH:GetFocusedTextBox() then
                        dD = dD % #dC + 1
                        for Y, cx in pairs(dI) do
                            cx.Visible = settings.TracersVisible and Tracer
                        end
                    elseif bM.KeyCode == settings.DisableKey and not dH:GetFocusedTextBox() then
                        settings.TracersVisible = not settings.TracersVisible
                        for Y, cx in pairs(dI) do
                            cx.Visible = settings.TracersVisible and Tracer
                        end
                    end
                end
            )
            if settings.DefaultSettings then
                settings.TeamCheck = false
                settings.TracersVisible = true
                settings.TracerColor = Color3.fromRGB(128, 0, 128)
                settings.TracerThickness = 1.8
                settings.TracerTransparency = 0.8
            end
        end
    }
)
local Z, dT = game.Players.LocalPlayer, false
local function dU(_)
    local dL = _:FindFirstChild("Head")
    if dL then
        local dV = dL:FindFirstChild("face")
        if dV then
            dV:Destroy()
        end
    end
end
local function dW(az)
    if az:IsA("Accessory") or az:IsA("Shirt") or az:IsA("Pants") or az.Name == "Face" then
        az:Destroy()
    elseif az:IsA("BasePart") then
        az.Material = Enum.Material.ForceField
        az.Color = Color3.fromRGB(225, 160, 255)
    end
end
local function dX(_)
    dU(_)
    for Y, az in ipairs(_:GetChildren()) do
        dW(az)
    end
    _.ChildAdded:Connect(dW)
end
local function dY(_)
    wait(0.14)
    if dT then
        dX(_)
    end
end
M:AddToggle(
    {Name = "Self visual", Value = false, Callback = function(d3)
            dT = d3
            if d3 then
                dY(Z.Character or Z.CharacterAdded:Wait())
            end
        end}
)
Z.CharacterAdded:Connect(dY)
