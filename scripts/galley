local a = loadstring(game:GetObjects("rbxassetid://7657867786")[1].Source)()
a.UnloadCallback = function()
    getgenv().Galley = nil
end
local b = game:GetService("Players")
local c = game:GetService("StarterGui")
local d = game:GetService("TweenService")
local e = game:GetService("RunService")
local f = game:GetService("ReplicatedStorage")
local g = game.Players.LocalPlayer
local h = f.Packages.Knit.Services.ToolService.RF
local i = g:GetMouse()
local j = workspace.CurrentCamera
local k = game.Players.LocalPlayer.Character.Humanoid.Health
local function l(m, n)
    h.ToggleBlockSword:InvokeServer(m, n)
end
local function o(p)
    local q = game.Players.LocalPlayer:WaitForChild("Backpack"):FindFirstChild(p)
    if q and q:IsA("Tool") then
        q.Parent = game.Players.LocalPlayer.Character or game.Players.LocalPlayer.CharacterAdded:Wait()
    end
end
local function r(p)
    local q = game.Players.LocalPlayer.Character or game.Players.LocalPlayer.CharacterAdded:Wait():FindFirstChild(p)
    if q and q:IsA("Tool") then
        q.Parent = game.Players.LocalPlayer:WaitForChild("Backpack")
    end
end
local function s(t, u, v, w)
    return Vector3.new(t.X + u.X * v, t.Y + w, t.Z + u.Z * v)
end
local x = a:CreateWindow({Name = "Galley | rw", Themeable = {Image = "7059346386", Credit = false}})
local y = x:CreateTab({Name = "Blatant"})
local z = y:CreateSection({Name = "Aura"})
local A = y:CreateSection({Name = "Bow Aura"})
local B = y:CreateSection({Name = "Movement", Side = "Right"})
local C = y:CreateSection({Name = "Strafe", Side = "Right"})
local D = y:CreateSection({Name = "Anti void", Side = "Right"})
local E = y:CreateSection({Name = "Anti lagback [beta]"})
local F = x:CreateTab({Name = "Closet"})
local G = F:CreateSection({Name = "Hitbox", Side = "Right"})
local H = F:CreateSection({Name = "Auto"})
local I = F:CreateSection({Name = "Lag", Side = "Right"})
local J = F:CreateSection({Name = "Aim"})
local K = x:CreateTab({Name = "Visuals"})
local L = K:CreateSection({Name = "chams"})
local M = K:CreateSection({Name = "Target hud"})
local N = K:CreateSection({Name = "Render", Side = "Right"})
local O, P, Q, R = "Closest", "PreSimulation", false, 24
z:AddDropdown(
    {
        Name = "RunService type",
        Default = "PreSimulation",
        List = {"Stepped", "PreSimulation", "Heartbeat", "RenderStepped", "PreRender", "PostSimulation"},
        Callback = function(S)
            P = S
        end
    }
)
local function T()
    local U = game:GetService("Players"):GetPlayers()
    local V = nil
    local W = math.huge
    for X, Y in ipairs(U) do
        local Z = Y.Character
        if Z and Z:FindFirstChild("Humanoid") and Z.Humanoid.Health > 0 and not Z:FindFirstChildOfClass("ForceField") then
            local _ =
                (Z.HumanoidRootPart.Position - game.Players.LocalPlayer.Character.HumanoidRootPart.Position).magnitude
            if _ < W then
                W = _
                V = Z.HumanoidRootPart.Position
            end
        end
    end
    return V
end
local function a0(a1)
    local a2 = nil
    local a3 = game.Players.LocalPlayer.Character.HumanoidRootPart.Position
    if a1 == "Closest" then
        local _ = math.huge
        for X, a4 in ipairs(game.Players:GetPlayers()) do
            if
                a4 ~= game.Players.LocalPlayer and a4.Character and a4.Character:FindFirstChild("HumanoidRootPart") and
                    a4.Character:FindFirstChild("Humanoid").Health > 0 and
                    not a4.Character:FindFirstChildOfClass("ForceField")
             then
                local a5 = (a3 - a4.Character.HumanoidRootPart.Position).Magnitude
                if a5 < _ then
                    a2, _ = a4, a5
                end
            end
        end
    elseif a1 == "Random" then
        local a6 = {}
        for X, a4 in ipairs(game.Players:GetPlayers()) do
            if
                a4 ~= game.Players.LocalPlayer and a4.Character and a4.Character:FindFirstChild("HumanoidRootPart") and
                    a4.Character:FindFirstChild("Humanoid").Health > 0 and
                    not a4.Character:FindFirstChildOfClass("ForceField")
             then
                local a5 = (a3 - a4.Character.HumanoidRootPart.Position).Magnitude
                if a5 <= R then
                    table.insert(a6, a4)
                end
            end
        end
        if #a6 > 0 then
            a2 = a6[math.random(1, #a6)]
        end
    elseif a1 == "Farthest" then
        local a7 = 0
        for X, a4 in ipairs(game.Players:GetPlayers()) do
            if
                a4 ~= game.Players.LocalPlayer and a4.Character and a4.Character:FindFirstChild("HumanoidRootPart") and
                    a4.Character:FindFirstChild("Humanoid").Health > 0 and
                    not a4.Character:FindFirstChildOfClass("ForceField")
             then
                local a5 = (a3 - a4.Character.HumanoidRootPart.Position).Magnitude
                if a5 > a7 and a5 <= R then
                    a2, a7 = a4, a5
                end
            end
        end
    elseif a1 == "Weakest" then
        local a8 = math.huge
        for X, a4 in ipairs(game.Players:GetPlayers()) do
            if
                a4 ~= game.Players.LocalPlayer and a4.Character and a4.Character:FindFirstChild("HumanoidRootPart") and
                    a4.Character:FindFirstChild("Humanoid").Health > 0 and
                    not a4.Character:FindFirstChildOfClass("ForceField")
             then
                local a5 = (a3 - a4.Character.HumanoidRootPart.Position).Magnitude
                if a5 <= R and a4.Character.Humanoid.Health < a8 then
                    a2, a8 = a4, a4.Character.Humanoid.Health
                end
            end
        end
    elseif a1 == "Strongest" then
        local a9 = 0
        for X, a4 in ipairs(game.Players:GetPlayers()) do
            if
                a4 ~= game.Players.LocalPlayer and a4.Character and a4.Character:FindFirstChild("HumanoidRootPart") and
                    a4.Character:FindFirstChild("Humanoid").Health > 0 and
                    not a4.Character:FindFirstChildOfClass("ForceField")
             then
                local a5 = (a3 - a4.Character.HumanoidRootPart.Position).Magnitude
                if a5 <= R and a4.Character.Humanoid.Health > a9 then
                    a2, a9 = a4, a4.Character.Humanoid.Health
                end
            end
        end
    end
    return a2
end
z:AddDropdown(
    {
        Name = "Targeting Mode",
        Default = "Closest",
        List = {"Closest", "Farthest", "Strongest", "Weakest", "Random"},
        Callback = function(S)
            O = S
        end
    }
)
local function aa()
    local ab = a0(O)
    if ab then
        local a5 =
            (game.Players.LocalPlayer.Character.HumanoidRootPart.Position - ab.Character.HumanoidRootPart.Position).Magnitude
        if a5 <= R and ab.Character.Humanoid.Health > 0 and not ab.Character:FindFirstChildOfClass("ForceField") then
            if Q then
                for X, ac in ipairs({"WoodenSword", "Sword"}) do
                    l(true, ac)
                end
            end
            for X, n in ipairs({"WoodenSword", "Sword"}) do
                h.AttackPlayerWithSword:InvokeServer(ab.Character, critsActive, n)
            end
        else
            if Q then
                for X, ac in ipairs({"WoodenSword", "Sword"}) do
                    l(false, ac)
                end
            end
        end
    end
end
local ad
local function ae(af)
    if af then
        if not ad then
            ad =
                game:GetService("RunService")[P]:Connect(
                function()
                    pcall(aa)
                end
            )
        end
    elseif ad then
        ad:Disconnect()
        ad = nil
    end
end
z:AddToggle({Name = "Aura", Default = false, Keybind = 1, Callback = ae})
z:AddToggle(
    {Name = "Auto block", Default = false, Callback = function(af)
            Q = af
        end}
)
z:AddToggle(
    {Name = "Crits", Default = false, Callback = function(af)
            critsActive = af
        end}
)
z:AddSlider(
    {Name = "Aura Range", Min = 1, Max = 36, Default = 24, Callback = function(S)
            R = S
        end}
)
local ag
z:AddToggle(
    {
        Name = "Click Aura",
        Default = false,
        Keybind = 1,
        Callback = function(ah)
            local Y = game.Players.LocalPlayer
            local i = Y:GetMouse()
            local function ai(Y)
                local aj, ak = nil, math.huge
                for X, al in pairs(game.Players:GetPlayers()) do
                    if al ~= Y and al.Character and al.Character:FindFirstChild("HumanoidRootPart") then
                        local _ =
                            (Y.Character.HumanoidRootPart.Position - al.Character.HumanoidRootPart.Position).Magnitude
                        if _ < ak then
                            ak, aj = _, al
                        end
                    end
                end
                return aj
            end
            local function am()
                local aj = ai(Y)
                if aj and aj.Character then
                    local an = {"WoodenSword", "Sword"}
                    for X, n in ipairs(an) do
                        local ao = {[1] = workspace:WaitForChild(aj.Name), [2] = true, [3] = n}
                        game:GetService("ReplicatedStorage"):WaitForChild("Packages"):WaitForChild("Knit"):WaitForChild(
                            "Services"
                        ):WaitForChild("ToolService"):WaitForChild("RF"):WaitForChild("AttackPlayerWithSword"):InvokeServer(
                            unpack(ao)
                        )
                    end
                end
            end
            if ah then
                ag = i.Button1Down:Connect(am)
            else
                if ag then
                    ag:Disconnect()
                    ag = nil
                end
            end
        end
    }
)
local function ap()
    if FaceTarget then
        local aq = T()
        task.wait(0.05)
        local ao = {[1] = Vector3.new(aq.X, aq.Y, aq.Z)}
        game:GetService("ReplicatedStorage"):WaitForChild("Packages"):WaitForChild("Knit"):WaitForChild("Services"):WaitForChild(
            "ToolService"
        ):WaitForChild("RF"):WaitForChild("UpdateHeadRotation"):InvokeServer(unpack(ao))
    end
end
game:GetService("RunService").Heartbeat:Connect(ap)
z:AddToggle(
    {Name = "Serverside Face", Default = false, Callback = function(af)
            FaceTarget = af
        end}
)
local ar, as, w, at, af = "Head", 30, 1, 0.1, false
A:AddDropdown(
    {
        Name = "Target Part",
        List = {
            "Head",
            "HumanoidRootPart",
            "LeftLowerArm",
            "RightLowerArm",
            "LeftUpperArm",
            "RightUpperArm",
            "LeftLowerLeg",
            "UpperTorso",
            "LeftUpperLeg",
            "RightLowerLeg",
            "LowerTorso",
            "RightUpperLeg"
        },
        Default = ar,
        Callback = function(au)
            ar = au
        end
    }
)
A:AddSlider(
    {Name = "Charge time", Min = 0, Max = 50, Default = as, Callback = function(S)
            as = S
        end}
)
A:AddSlider(
    {Name = "Y Offset", Min = -15, Max = 15, Default = w, Callback = function(S)
            w = S
        end}
)
A:AddSlider(
    {Name = "Prediction", Min = 0, Max = 3.0, Default = at, Precise = 1, Callback = function(S)
            at = S
        end}
)
A:AddToggle(
    {Name = "Bow Aura", Callback = function(av)
            af = av
            if af then
                local aw = game.Players.LocalPlayer
                local function ax()
                    while true do
                        if af then
                            local Z = aw.Character or aw.CharacterAdded:Wait()
                            local ay = Z:WaitForChild(ar)
                            local az = ay and ay.Position
                            if not az then
                                return
                            end
                            local aj, ak, aA
                            for X, Y in ipairs(game.Players:GetPlayers()) do
                                if Y ~= aw and Y.Character then
                                    local aB = Y.Character:FindFirstChild(ar)
                                    local t = aB and aB.Position
                                    local aC = Y.Character:FindFirstChildOfClass("Humanoid").RootPart.Velocity
                                    if t then
                                        local _ = (t - az).magnitude
                                        local aD = s(t, aC, at, w)
                                        local aE = (aD - az).magnitude
                                        if not ak or aE < ak then
                                            aj = Y
                                            ak = aE
                                            aA = aD
                                        end
                                    end
                                end
                            end
                            if aj and aA then
                                o("DefaultBow")
                                game.Players.LocalPlayer.Character.DefaultBow.__comm__.RF.Fire:InvokeServer(aA, as)
                                r("DefaultBow")
                            end
                        end
                        task.wait(2.995)
                    end
                end
                coroutine.wrap(ax)()
            end
        end}
)
local af = false
local aF = 10
local aG = 20
local aH = 0.3
local aI = 0.001
local ag
local function aJ(aK)
    aI = aI + aK
    if aI < aH then
        return
    end
    aI = 0
    local b = game:GetService("Players")
    local Y = b.LocalPlayer
    local Z = Y.Character
    if not Z then
        return
    end
    local aL = Z:FindFirstChild("Humanoid")
    if not aL then
        return
    end
    local aM = Z:FindFirstChild("HumanoidRootPart")
    if not aM then
        return
    end
    local aN = aM.CFrame
    local _ = (aN.Position - lastValidPosition.Position).Magnitude
    if _ > aF and _ < aG then
        local aC = aL.MoveDirection * aL.WalkSpeed
        local aO = lastValidPosition.Position + aC * aH
        if (aN.Position - aO).Magnitude > aF then
            Z:SetPrimaryPartCFrame(lastValidPosition)
        else
            lastValidPosition = aN
        end
    else
        lastValidPosition = aN
    end
end
E:AddToggle(
    {Name = "Anti lagback", Default = false, Callback = function(av)
            af = av
            if af then
                local b = game:GetService("Players")
                local e = game:GetService("RunService")
                local Y = b.LocalPlayer
                local Z = Y.Character or Y.CharacterAdded:Wait()
                lastValidPosition = Z.PrimaryPart.CFrame
                ag = e.Heartbeat:Connect(aJ)
            else
                if ag then
                    ag:Disconnect()
                    ag = nil
                end
            end
        end}
)
E:AddSlider(
    {
        Name = "Lag Back Threshold",
        Min = 0,
        Max = 30,
        Default = aF,
        Increment = 0.1,
        ValueName = "studs",
        Callback = function(S)
            aF = S
        end
    }
)
E:AddSlider(
    {
        Name = "Max Prevention Distance",
        Min = 0,
        Max = 50,
        Default = aG,
        Increment = 0.1,
        ValueName = "studs",
        Callback = function(S)
            aG = S
        end
    }
)
E:AddSlider(
    {
        Name = "Update Delay",
        Min = 0,
        Max = 1,
        Default = aH,
        Increment = 0.01,
        ValueName = "seconds",
        Callback = function(S)
            aH = S
        end
    }
)
local aP, aQ, aR, aS, aT, aU = 1.0, false, false, 1.0 / 200, false, false
local function aV()
    if aR then
        aT = true
        if aU then
            aU:Disconnect()
        end
        aU =
            game:GetService("RunService").Stepped:Connect(
            function()
                if not aT then
                    return
                end
                local aW = aS
                if aQ and game.Players.LocalPlayer:GetAttribute("Blocking") == true then
                    aW = aW * aP
                end
                local Z = game.Players.LocalPlayer.Character
                if Z and Z:FindFirstChild("HumanoidRootPart") then
                    Z.HumanoidRootPart.CFrame = Z.HumanoidRootPart.CFrame + Z.Humanoid.MoveDirection * aW
                end
            end
        )
    else
        aT = false
        if aU then
            aU:Disconnect()
        end
    end
end
B:AddSlider(
    {Name = "Block speed", Min = 1, Max = 2.20, Value = aP, Precise = 2, Callback = function(S)
            aP = S
        end}
)
B:AddToggle(
    {Name = "Block noslow", Value = aQ, Callback = function(af)
            aQ = af
        end}
)
B:AddToggle(
    {Name = "Speed", Value = aR, Keybind = 1, Callback = function(af)
            aR = af
            aV()
        end}
)
B:AddSlider(
    {Name = "Speed", Min = 0, Max = 50, Value = aS * 200, Callback = function(aX, aY)
            aS = aX / 200
            if aR then
                aV()
            end
        end}
)
game.Players.LocalPlayer.CharacterAdded:Connect(
    function()
        aV()
    end
)
local af = false
local aZ = 0
B:AddToggle(
    {
        Name = "Derp",
        Default = false,
        Callback = function(av)
            af = av
            if af then
                local b, d = game:GetService("Players"), game:GetService("TweenService")
                local Y, a_ = b.LocalPlayer, b.LocalPlayer.Character:WaitForChild("HumanoidRootPart")
                local b0 = TweenInfo.new(0, Enum.EasingStyle.Linear, Enum.EasingDirection.Out)
                local b1 = 0.01
                local b2 = 0
                local function b3()
                    b2 = (b2 + aZ) % (2 * math.pi)
                    local b4 = b2
                    local b5 = math.cos(b4) * b1
                    local b6 = math.sin(b4) * b1
                    local t = a_.Position + Vector3.new(b5, 0, b6)
                    local b7 = (t - a_.Position).Unit
                    local b8 = CFrame.new(a_.Position, a_.Position + b7)
                    local b9 = d:Create(a_, b0, {CFrame = b8})
                    b9:Play()
                end
                local ba
                ba =
                    game:GetService("RunService").Heartbeat:Connect(
                    function()
                        if af then
                            b3()
                        else
                            ba:Disconnect()
                        end
                    end
                )
            end
        end
    }
)
B:AddSlider(
    {Name = "Derp spin speed", Min = 0, Max = 30, Precise = 2, Default = aZ, Callback = function(S)
            aZ = S
        end}
)
B:AddSlider(
    {Name = "Gravity", Min = 0, Max = 192, Callback = function(aX, aY)
            workspace.Gravity = aX
        end}
)
local bb, bc, bd = {}, nil, false
local function be()
    for X, ay in pairs(game.Players.LocalPlayer.Character:GetDescendants()) do
        if ay:IsA("BasePart") and ay.CanCollide then
            bb[ay] = true
            ay.CanCollide = false
        end
    end
end
B:AddToggle(
    {Name = "Phase", Value = bd, Keybind = 1, Callback = function(af)
            bd = af
            if af then
                bc = game:GetService("RunService").Stepped:Connect(be)
            else
                if bc then
                    bc:Disconnect()
                end
                for ay in pairs(bb) do
                    if ay then
                        ay.CanCollide = true
                    end
                end
                table.clear(bb)
            end
        end}
)
local bf, bg = false, 0.80
B:AddToggle(
    {Name = "Air Check", Value = bf, Callback = function(af)
            bf = af
        end}
)
B:AddToggle(
    {Name = "Bhop", Value = BhopActive, Keybind = 1, Callback = function(af)
            BhopActive = af
            if af then
                while af do
                    if
                        not bf or
                            game.Players.LocalPlayer.Character.Humanoid:GetState() ~= Enum.HumanoidStateType.Freefall
                     then
                        game.Players.LocalPlayer.Character:WaitForChild("Humanoid"):ChangeState(
                            Enum.HumanoidStateType.Jumping
                        )
                        task.wait(bg)
                    end
                    if not BhopActive then
                        break
                    end
                    task.wait()
                end
            end
        end}
)
B:AddSlider(
    {Name = "Bhop delay", Min = 0, Max = 1, Precise = 2, Value = bg, Callback = function(aX, aY)
            bg = aX
        end}
)
local bh = false
local bi
local function b3(Z)
    if Z:FindFirstChild("HumanoidRootPart") then
        local bj = Z.HumanoidRootPart.Position
        local w = Z.Humanoid.HipHeight - -1
        bi.Position = Vector3.new(bj.X, bj.Y - w, bj.Z)
    end
end
B:AddToggle(
    {Name = "Fly", Value = bh, Keybind = 1, Callback = function(af)
            bh = af
            local Y = game.Players.LocalPlayer
            local Z = Y.Character or Y.CharacterAdded:Wait()
            if af then
                bi = Instance.new("Part")
                bi.Size = Vector3.new(2, 0.1, 2)
                bi.Anchored = true
                bi.CanCollide = true
                bi.Transparency = 1
                bi.BrickColor = BrickColor.new("Medium stone grey")
                bi.Parent = game.Workspace
                while bh do
                    b3(Z)
                    task.wait()
                end
            else
                if bi then
                    bi:Destroy()
                end
            end
        end}
)
local bk, bl = false, 0.02
local function bm(bn, bo, bp)
    local bq, br, bs = math.clamp, Vector3.new, tick()
    local bt = game.Players.LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
    if bt then
        bt.Anchored = true
    end
    while tick() - bs <= bl do
        if bt then
            bt.Velocity = br(bq(bt.Velocity.X, -bn, bn), bq(bt.Velocity.Y, -bo, bo), bq(bt.Velocity.Z, -bp, bp))
        end
        task.wait()
    end
    if bt then
        bt.Anchored = false
    end
end
local function bu(bv)
    if bk and k and bv < k then
        bm(0, 0, 0)
    end
    k = bv
end
local function bw()
    while bk do
        bu(game.Players.LocalPlayer.Character.Humanoid.Health)
        task.wait(0.03)
    end
end
game.Players.LocalPlayer.Character.Humanoid.HealthChanged:Connect(bu)
B:AddToggle(
    {Name = "Antikb", Default = false, Callback = function(S)
            bk = S
            if bk then
                spawn(bw)
            end
        end}
)
B:AddSlider(
    {Name = "Anti kb no-move", Min = 0, Max = 1, Precise = 2, Default = 0.02, Callback = function(S)
            bl = S
        end}
)
local bx = false
local by = false
local bz = 20
local bA = 5
local bB = 20
local bC = 0.1
local bD = nil
local bE = nil
local function bF()
    local ak = math.huge
    local bG = nil
    local Y = game.Players.LocalPlayer
    local Z = Y.Character or Y.CharacterAdded:Wait()
    local U = game:GetService("Players")
    for X, al in pairs(U:GetPlayers()) do
        if al ~= Y and al.Character and al.Character:FindFirstChild("HumanoidRootPart") then
            local _ = (Z.HumanoidRootPart.Position - al.Character.HumanoidRootPart.Position).magnitude
            if _ < ak and al.Character.Humanoid.Health > 0 then
                ak = _
                bG = al
            end
        end
    end
    return bG
end
local function bH(b4, t)
    local bI = Vector3.new(math.cos(b4) * bA, 0, math.sin(b4) * bA)
    return t + bI
end
local function b3()
    local Y = game.Players.LocalPlayer
    local Z = Y.Character
    if not Z then
        return
    end
    local a_ = Z:FindFirstChild("HumanoidRootPart")
    if not a_ then
        return
    end
    if bD and bD.Character then
        local bJ = bD.Character
        local bK = bJ:FindFirstChild("HumanoidRootPart")
        if bK and bJ.Humanoid.Health > 0 then
            local t = bK.Position
            local _ = (a_.Position - t).magnitude
            if _ <= bB then
                if by then
                    task.wait(0.0195)
                    if Y:GetAttribute("Blocking") then
                        Y:SetAttribute("Blocking", false)
                        task.wait(0.068)
                        a_.CFrame = a_.CFrame:lerp(CFrame.new(t), bC)
                        Y:SetAttribute("Blocking", true)
                    else
                        a_.CFrame = a_.CFrame:lerp(CFrame.new(t), bC)
                    end
                else
                    local bL = bH(tick() * bz / 10, t)
                    a_.CFrame = a_.CFrame:lerp(CFrame.new(bL), bC)
                end
            else
                bD = nil
            end
        else
            bD = nil
        end
    else
        bD = bF()
    end
end
local function bM(S)
    bx = S
    if S then
        bE = game:GetService("RunService").RenderStepped:Connect(b3)
    elseif bE then
        bE:Disconnect()
        bE = nil
    end
end
local function bN(S)
    by = S
end
C:AddToggle({Name = "Strafe", Keybind = 1, Default = false, Callback = bM})
C:AddToggle({Name = "Anti Tp Flag", Default = false, Callback = bN})
C:AddSlider(
    {Name = "Strafe Speed", Min = 1, Max = 100, Precise = 1, Value = bz, Callback = function(aX, aY)
            bz = aX
        end}
)
C:AddSlider(
    {Name = "Smoothness", Min = 0.1, Max = 1, Precise = 2, Value = bC, Callback = function(aX, aY)
            bC = aX
        end}
)
C:AddSlider(
    {Name = "Strafe Distance", Min = 1, Max = 20, Precise = 1, Value = bA, Callback = function(aX, aY)
            bA = aX
        end}
)
C:AddSlider(
    {Name = "Max Target Distance", Min = 1, Max = 50, Value = bB, Callback = function(aX, aY)
            bB = aX
        end}
)
local bO
D:AddToggle(
    {Name = "Antivoid", Value = false, Callback = function(af)
            if af then
                bO = Instance.new("Part")
                bO.Name = "Antivoid"
                bO.Position = Vector3.new(0, -150, 0)
                bO.Size = Vector3.new(1000, 1, 1000)
                bO.Anchored = true
                bO.CanCollide = true
                bO.Transparency = 1
                bO.BrickColor = BrickColor.new("Medium stone grey")
                bO.Parent = game.Workspace
            else
                local bP = game.Workspace:FindFirstChild("Antivoid")
                if bP then
                    bP:Destroy()
                end
            end
        end}
)
local bQ =
    D:AddSlider(
    {Name = "Antivoid Transparency", Value = 0, Min = 0, Max = 1, Precise = 1, Callback = function(bR)
            if bO then
                bO.Transparency = bR
            end
        end}
)
local bS, bT, bU, bV, bW, bX, bY, bZ = 1, 1, 1, false, nil, 0.5, Enum.Material.Neon, Color3.fromRGB(225, 160, 255)
G:AddSlider(
    {Name = "X axis", Min = 1, Max = 10, Callback = function(S)
            bS = S
        end}
)
G:AddSlider(
    {Name = "Y axis", Min = 1, Max = 10, Callback = function(S)
            bT = S
        end}
)
G:AddSlider(
    {Name = "Z axis", Min = 1, Max = 10, Callback = function(S)
            bU = S
        end}
)
G:AddSlider(
    {Name = "Transparency", Min = 0, Max = 1, Callback = function(S)
            bX = S
        end}
)
G:AddDropdown(
    {
        Name = "Material",
        List = {"Plastic", "SmoothPlastic", "Neon", "ForceField", "Glass"},
        Default = "Neon",
        Callback = function(au)
            if au == "Plastic" then
                bY = Enum.Material.Plastic
            elseif au == "SmoothPlastic" then
                bY = Enum.Material.SmoothPlastic
            elseif au == "Neon" then
                bY = Enum.Material.Neon
            elseif au == "ForceField" then
                bY = Enum.Material.ForceField
            elseif au == "Glass" then
                bY = Enum.Material.Glass
            end
        end
    }
)
G:AddColorPicker(
    {Name = "Color", Default = bZ, Callback = function(b_)
            bZ = b_
        end}
)
G:AddToggle(
    {Name = "Hitbox Visual", Callback = function(af)
            bV = af
        end}
)
G:AddToggle(
    {
        Name = "Hitbox",
        Callback = function(af)
            if af then
                local function c0()
                    bW =
                        game:GetService("RunService").RenderStepped:Connect(
                        function()
                            for X, Y in ipairs(game:GetService("Players"):GetPlayers()) do
                                if Y.Name ~= game:GetService("Players").LocalPlayer.Name then
                                    pcall(
                                        function()
                                            local a_ = Y.Character and Y.Character:FindFirstChild("HumanoidRootPart")
                                            if a_ then
                                                a_.Size = Vector3.new(bS, bT, bU)
                                                a_.Transparency = bV and bX or 1
                                                a_.Material = bY
                                                a_.Color = bZ
                                                a_.CanCollide = false
                                            end
                                        end
                                    )
                                end
                            end
                        end
                    )
                end
                c0()
            else
                if bW then
                    bW:Disconnect()
                    bW = nil
                end
                for X, Y in ipairs(game:GetService("Players"):GetPlayers()) do
                    if Y.Name ~= game:GetService("Players").LocalPlayer.Name then
                        pcall(
                            function()
                                local a_ = Y.Character and Y.Character:FindFirstChild("HumanoidRootPart")
                                if a_ then
                                    a_.Size = Vector3.new(2, 2, 2)
                                    a_.Transparency = 1
                                    a_.Material = Enum.Material.Plastic
                                    a_.CanCollide = false
                                end
                            end
                        )
                    end
                end
            end
        end
    }
)
local c1, c2, c3 = false, false, 18
H:AddToggle(
    {Name = "Auto Clicker", Keybind = 1, Callback = function(af)
            c1 = af
            if af then
                c2 = true
                while c1 and c2 do
                    mouse1click()
                    task.wait(1 / c3)
                end
            else
                c2 = false
            end
        end}
)
H:AddSlider(
    {Name = "CPS", Min = 1, Max = 50, Def = c3, Callback = function(bR)
            c3 = bR
        end}
)
local c4, i, c5, c6 = game:GetService("UserInputService"), game.Players.LocalPlayer:GetMouse(), false, false
local ag
H:AddToggle(
    {
        Name = "Double click",
        Callback = function(af)
            c6 = af
            if af then
                ag =
                    c4.InputBegan:Connect(
                    function(c7, c8)
                        if not c8 and c7.UserInputType == Enum.UserInputType.MouseButton1 and not c5 then
                            task.wait(0.1)
                            c5 = true
                            mouse1click()
                            c5 = false
                        end
                    end
                )
            elseif ag then
                ag:Disconnect()
            end
        end
    }
)
H:AddToggle(
    {
        Name = "Trigger bot",
        Keybind = 1,
        Callback = function(af)
            triggerbotActive = af
            local c9
            local ca = 0
            local minInterval = 1 / cpslimit
            local function cb(cc)
                for X, Y in pairs(game.Players:GetPlayers()) do
                    if Y.Character and cc and cc:IsDescendantOf(Y.Character) then
                        return true
                    end
                end
                return false
            end
            if af then
                c9 =
                    game:GetService("RunService").Heartbeat:Connect(
                    function()
                        if cb(game.Players.LocalPlayer:GetMouse().Target) then
                            local cd = tick()
                            if cd - ca >= minInterval then
                                ca = cd
                                mouse1press()
                                task.wait()
                                mouse1release()
                            end
                        end
                    end
                )
                getgenv().disable = function()
                    if c9 then
                        warn("Disconnecting:", c9)
                        c9:Disconnect()
                        c9 = nil
                    end
                    getgenv().disable = nil
                end
            else
                if getgenv().disable then
                    getgenv().disable()
                end
            end
        end
    }
)
H:AddSlider(
    {Name = "CPS limit", Min = 1, Max = 50, Def = cpslimit, Callback = function(bR)
            cpslimit = bR
            minInterval = 1 / cpslimit
        end}
)
local ce, cf, cg, ch, ci = "None", 0, 0, 0, 0
local function cj(S)
    settings():GetService("NetworkSettings").IncomingReplicationLag = S
end
I:AddDropdown(
    {
        Name = "Method",
        List = {"ReplicationLag", "Axis", "None"},
        Default = ce,
        Callback = function(au)
            ce = au
            if ce == "ReplicationLag" then
                getgenv().Axis = false
                cj(cf)
            elseif ce == "Axis" then
                getgenv().Axis = true
                getgenv().Z = ci
                getgenv().Y = ch
                getgenv().X = cg
                game:GetService("RunService").Heartbeat:Connect(
                    function()
                        if getgenv().Axis then
                            local ck = game.Players.LocalPlayer.Character.HumanoidRootPart.Velocity
                            game.Players.LocalPlayer.Character.HumanoidRootPart.Velocity =
                                Vector3.new(getgenv().X, getgenv().Y, getgenv().Z)
                            game:GetService("RunService").RenderStepped:Wait()
                            game.Players.LocalPlayer.Character.HumanoidRootPart.Velocity = ck
                        end
                    end
                )
                cj(0)
            end
        end
    }
)
I:AddSlider(
    {Name = "Client Lag", Min = 0, Max = 10, Precise = 2, Def = cf, Callback = function(bR)
            cf = bR
            if ce == "ReplicationLag" then
                cj(cf)
            end
        end}
)
I:AddSlider(
    {Name = "Axis Lag x", Min = 0, Max = 500, Def = cg, Callback = function(bR)
            cg = bR
        end}
)
I:AddSlider(
    {Name = "Axis Lag y", Min = 0, Max = 500, Def = ch, Callback = function(bR)
            ch = bR
        end}
)
I:AddSlider(
    {Name = "Axis Lag z", Min = 0, Max = 500, Def = ci, Callback = function(bR)
            ci = bR
        end}
)
local cl, cm, cn, co, ar = false, 1, 30, 30, "Head"
local function cp(cq, cr, cs, ct)
    return cq:Lerp(cr, cs * ct)
end
local function cu(aK)
    if cl then
        local cv = nil
        local W = math.huge
        local aw = game:GetService("Players").LocalPlayer
        local cw = aw.Character
        if cw then
            local cx = cw:FindFirstChild(ar).Position
            local cy = cw:FindFirstChild(ar).CFrame.lookVector
            for X, Y in ipairs(game:GetService("Players"):GetPlayers()) do
                if Y ~= aw then
                    local cz = Y.Character
                    if cz then
                        local cA = cz:FindFirstChild(ar) and cz:FindFirstChild(ar).Position
                        if cA then
                            local _ = (cx - cA).magnitude
                            if _ < W and _ <= cn then
                                local cB = (cA - cx).unit
                                local b4 = math.acos(cy:Dot(cB)) * 180 / math.pi
                                if b4 <= co then
                                    W = _
                                    cv = Y
                                end
                            end
                        end
                    end
                end
            end
        end
        if cv then
            local cC = game:GetService("Workspace").CurrentCamera.CFrame
            local cD = cv.Character:FindFirstChild(ar) and cv.Character:FindFirstChild(ar).Position
            if cD then
                local cE = CFrame.new(cC.Position, cD)
                local cF = cp(cC, cE, aK, cm)
                game:GetService("Workspace").CurrentCamera.CFrame = cF
            end
        end
    end
end
J:AddToggle(
    {Name = "Aim Assist", Keybind = 1, Callback = function(af)
            cl = af
        end}
)
J:AddDropdown(
    {
        Name = "Target Part",
        List = {
            "Head",
            "HumanoidRootPart",
            "LeftLowerArm",
            "RightLowerArm",
            "LeftUpperArm",
            "RightUpperArm",
            "LeftLowerLeg",
            "UpperTorso",
            "LeftUpperLeg",
            "RightLowerLeg",
            "LowerTorso",
            "RightUpperLeg"
        },
        Default = ar,
        Callback = function(au)
            ar = au
        end
    }
)
J:AddSlider(
    {Name = "Smoothness", Min = 1, Max = 25, Default = 1, Precise = 2, Callback = function(S)
            cm = S
        end}
)
J:AddSlider(
    {Name = "Range", Min = 5, Max = 100, Default = 30, Callback = function(S)
            cn = S
        end}
)
J:AddSlider(
    {Name = "Aim fov", Min = 0, Max = 360, Default = 30, Callback = function(S)
            co = S
        end}
)
game:GetService("RunService").RenderStepped:Connect(
    function(aK)
        cu(aK)
    end
)
local cG, cH, cI, cJ = 40, 8, 0.8, 0.8
M:AddSlider(
    {Name = "Hide distance", Min = 0, Max = 250, Value = cG, Callback = function(S)
            cG = S
        end}
)
M:AddSlider(
    {Name = "Corners", Min = 0, Max = 50, Value = cH, Callback = function(S)
            cH = S
        end}
)
M:AddSlider(
    {Name = "Position X", Min = 0, Max = 1, Precise = 2, Value = cI, Callback = function(S)
            cI = S
            if gui then
                gui.Frame.Position = UDim2.new(cI, 0, cJ, 0)
            end
        end}
)
M:AddSlider(
    {Name = "Position Y", Min = 0, Max = 1, Precise = 2, Value = cJ, Callback = function(S)
            cJ = S
            if gui then
                gui.Frame.Position = UDim2.new(cI, 0, cJ, 0)
            end
        end}
)
local gui
local function cK()
    if gui then
        gui:Destroy()
    end
    gui = Instance.new("ScreenGui")
    gui.Name = "PlayerInfoGUI"
    gui.ResetOnSpawn = false
    gui.Parent = game.Players.LocalPlayer:WaitForChild("PlayerGui")
    local cL = Instance.new("Frame", gui)
    cL.Name = "Frame"
    cL.Size = UDim2.new(0.1, 0, 0.08, 0)
    cL.Position = UDim2.new(cI, 0, cJ, 0)
    cL.BackgroundColor3 = Color3.new(0, 0, 0)
    cL.BackgroundTransparency = 0.5
    cL.BorderSizePixel = 2
    cL.BorderColor3 = Color3.fromRGB(148, 0, 211)
    cL.Active = true
    local cM = Instance.new("UICorner", cL)
    cM.CornerRadius = UDim.new(0, cH)
    local cN = Instance.new("TextLabel", cL)
    cN.Text = "..."
    cN.TextColor3 = Color3.new(1, 1, 1)
    cN.Size = UDim2.new(1, 0, 0.3, 0)
    cN.Position = UDim2.new(0, 0, 0, 0)
    cN.BackgroundTransparency = 1
    cN.Font = Enum.Font.SourceSansBold
    cN.TextSize = 20
    cN.TextWrapped = true
    cN.TextXAlignment = Enum.TextXAlignment.Center
    local cO = Instance.new("TextLabel", cL)
    cO.Text = ""
    cO.TextColor3 = Color3.new(1, 1, 1)
    cO.Size = UDim2.new(1, 0, 0.3, 0)
    cO.Position = UDim2.new(0, 0, 0.3, 0)
    cO.BackgroundTransparency = 1
    cO.Font = Enum.Font.SourceSansBold
    cO.TextSize = 20
    cO.TextWrapped = true
    cO.TextXAlignment = Enum.TextXAlignment.Center
    local cP = Instance.new("Frame", cL)
    cP.Size = UDim2.new(0.6, 0, 0.2, 0)
    cP.Position = UDim2.new(0.2, 0, 0.7, 0)
    cP.BackgroundColor3 = Color3.new(0, 0, 0)
    cP.BorderSizePixel = 2
    cP.BorderColor3 = Color3.new(0, 0, 0)
    local cQ = Instance.new("Frame", cL)
    cQ.Size = UDim2.new(0.6, 0, 0.2, 0)
    cQ.Position = UDim2.new(0.2, 0, 0.7, 0)
    cQ.BackgroundColor3 = Color3.fromRGB(0, 255, 0)
    cQ.BorderSizePixel = 0
    local cR = Instance.new("TextLabel", cL)
    cR.Text = ""
    cR.TextColor3 = Color3.new(1, 0, 0)
    cR.Size = UDim2.new(0.6, 0, 0.3, 0)
    cR.Position = UDim2.new(0.615, 0, 0.7, 0)
    cR.BackgroundTransparency = 1
    cR.Font = Enum.Font.SourceSansBold
    cR.TextSize = 16
    cR.TextWrapped = true
    cR.TextXAlignment = Enum.TextXAlignment.Center
    local cS = Instance.new("Frame", cL)
    cS.Size = UDim2.new(1, 0, 0, 2)
    cS.Position = UDim2.new(0, 0, 0.3, 0)
    cS.BorderSizePixel = 0
    cS.BackgroundColor3 = Color3.fromRGB(148, 0, 211)
    cS.BackgroundTransparency = 0.5
    local cT = Instance.new("Frame", cL)
    cT.Size = UDim2.new(1, 4, 1, 4)
    cT.Position = UDim2.new(-0.01, 0, -0.01, 0)
    cT.BackgroundColor3 = Color3.fromRGB(100, 0, 150)
    cT.BorderSizePixel = 0
    cT.ZIndex = -1
    local cU = Instance.new("TextLabel", cL)
    cU.TextColor3 = Color3.new(1, 1, 1)
    cU.Size = UDim2.new(1, 0, 0.1, 0)
    cU.Position = UDim2.new(0.05, 0, cR.Position.Y.Scale, cR.Position.Y.Offset - -8)
    cU.BackgroundTransparency = 1
    cU.Font = cR.Font
    cU.TextSize = cR.TextSize
    cU.TextWrapped = true
    cU.TextXAlignment = Enum.TextXAlignment.Left
    local function cV()
        local aj, ak = nil, math.huge
        local cW = game.Players.LocalPlayer.Character.HumanoidRootPart.Position
        local cX = false
        for X, Y in ipairs(game.Players:GetPlayers()) do
            local Z = Y.Character
            if Y ~= game.Players.LocalPlayer and Z and Z:FindFirstChild("HumanoidRootPart") then
                local _ = (Z.HumanoidRootPart.Position - cW).magnitude
                if _ < cG then
                    cX = true
                    if _ < ak then
                        aj, ak = Y, _
                    end
                end
            end
        end
        if cX then
            cN.Text = aj.Name
            local cY = math.floor(aj.Character.Humanoid.Health)
            local cZ = tostring(cY)
            local c_ = aj.Character.Humanoid.MaxHealth
            local d0 = cY / c_
            local d1 = UDim2.new(0.6 * d0, 0, 0.2, 0)
            local b0 = TweenInfo.new(0.18, Enum.EasingStyle.Linear, Enum.EasingDirection.Out)
            local d2 = d:Create(cQ, b0, {Size = d1})
            d2:Play()
            local b_ = Color3.fromRGB(255 * (1 - d0), 255 * d0, 0)
            cQ.BackgroundColor3 = b_
            local d3 = cO.Text
            local d4 = 1
            local d5 = math.max(#d3, #cZ)
            local d6 = 0.08
            local d7
            d7 =
                game:GetService("RunService").Heartbeat:Connect(
                function()
                    if d4 <= d5 then
                        cO.Text = cZ:sub(1, d4)
                        d4 = d4 + 1
                    else
                        d7:Disconnect()
                    end
                end
            )
            cO.Visible = true
            cP.Visible = true
            cQ.Visible = true
            local d8 = math.floor(game.Players.LocalPlayer.Character.Humanoid.Health)
            if d8 > cY then
                cR.Text = "winning"
                cR.TextColor3 = Color3.new(0, 1, 0)
            elseif d8 < cY then
                cR.Text = "losing"
                cR.TextColor3 = Color3.new(1, 0, 0)
            else
                cR.Text = "even"
                cR.TextColor3 = Color3.fromRGB(44, 25, 239)
            end
            cR.Font = Enum.Font.FredokaOne
            local d9 = string.format("%.1f", ak)
            if cU.Text ~= d9 then
                local da = cU.Text
                local db = 1
                local dc = math.max(#da, #d9)
                local dd = 0.03
                local de
                de =
                    game:GetService("RunService").Heartbeat:Connect(
                    function()
                        if db <= dc then
                            cU.Text = d9:sub(1, db)
                            db = db + 1
                        else
                            de:Disconnect()
                        end
                    end
                )
            end
            cU.Visible = true
            cR.Visible = true
            cL.Visible = true
        else
            cN.Text = ""
            cO.Visible = false
            cP.Visible = false
            cQ.Visible = false
            cR.Visible = false
            cU.Visible = false
            cL.Visible = false
        end
    end
    game:GetService("RunService").Heartbeat:Connect(cV)
end
M:AddToggle(
    {Name = "Target Hud", Callback = function(af)
            if af then
                cK()
            else
                if gui then
                    gui:Destroy()
                    gui = nil
                end
            end
        end}
)
local df = {Ambient = nil, OutdoorAmbient = nil, FogColor = nil, FogStart = nil, FogEnd = nil, PartColors = {}}
local dg, dh, di = Color3.new(225, 160, 255), Color3.fromRGB(225, 160, 255), Vector3.new(2, 1, 3)
local dj = false
local function dk(af)
    local dl = game:GetService("Lighting")
    if af then
        df.Ambient = dl.Ambient
        df.OutdoorAmbient = dl.OutdoorAmbient
        df.FogColor = dl.FogColor
        df.FogStart = dl.FogStart
        df.FogEnd = dl.FogEnd
        for X, ay in ipairs(workspace:GetDescendants()) do
            if ay:IsA("BasePart") then
                df.PartColors[ay] = ay.Color
            end
        end
        dl.Ambient = dg
        dl.OutdoorAmbient = dg
        dl.FogColor = dg
        dl.FogStart = df.FogStart or 0
        dl.FogEnd = df.FogEnd or 100
        for X, ay in ipairs(workspace:GetDescendants()) do
            if ay:IsA("BasePart") then
                ay.Color = dg
            end
        end
    else
        dl.Ambient = df.Ambient
        dl.OutdoorAmbient = df.OutdoorAmbient
        dl.FogColor = df.FogColor
        dl.FogStart = df.FogStart
        dl.FogEnd = df.FogEnd
        for X, ay in ipairs(workspace:GetDescendants()) do
            if ay:IsA("BasePart") and df.PartColors[ay] then
                ay.Color = df.PartColors[ay]
            end
        end
    end
end
N:AddToggle(
    {Name = "Ambient", Callback = function(af)
            dk(af)
        end}
)
local dm = {}
N:AddToggle(
    {Name = "Low gfx", Callback = function(dn)
            local workspace = game:GetService("Workspace")
            for X, ay in ipairs(workspace:GetDescendants()) do
                if ay:IsA("BasePart") then
                    if dn then
                        dm[ay] = ay.Material
                        ay.Material = Enum.Material.Ice
                    else
                        ay.Material = dm[ay] or ay.Material
                        dm[ay] = nil
                    end
                end
            end
        end}
)
N:AddToggle(
    {Name = "Better sword", Callback = function(af)
            dj = af
            if not dj then
                local dp = game:GetService("Workspace").Camera.Viewmodel.WoodenSword.MainPart.Mesh
                dp.VertexColor = Vector3.new(225 / 255, 160 / 255, 255 / 255)
                dp.Offset = Vector3.new(0, 0, 0)
            end
        end}
)
game:GetService("RunService").Heartbeat:Connect(
    function()
        if dj then
            local dp = game:GetService("Workspace").Camera.Viewmodel.WoodenSword.MainPart.Mesh
            dp.VertexColor = Vector3.new(dh.r, dh.g, dh.b)
            dp.Offset = di
        end
    end
)
N:AddSlider(
    {Name = "Sword front", Min = -10, Max = 10, Value = di.X, Callback = function(S)
            di = Vector3.new(S, di.Y, di.Z)
            if af then
                game:GetService("Workspace").Camera.Viewmodel.WoodenSword.MainPart.Mesh.Offset = di
            end
        end}
)
N:AddSlider(
    {Name = "Sword vertical", Min = -10, Max = 10, Value = di.Y, Callback = function(S)
            di = Vector3.new(di.X, S, di.Z)
            if af then
                game:GetService("Workspace").Camera.Viewmodel.WoodenSword.MainPart.Mesh.Offset = di
            end
        end}
)
N:AddSlider(
    {Name = "Sword side", Min = -10, Max = 10, Value = di.Z, Callback = function(S)
            di = Vector3.new(di.X, di.Y, S)
            if af then
                game:GetService("Workspace").Camera.Viewmodel.WoodenSword.MainPart.Mesh.Offset = di
            end
        end}
)
N:AddSlider(
    {Name = "Fog Start", Min = 0, Max = 1000, Value = df.FogStart or 0, Callback = function(S)
            df.FogStart = S
            if dj then
                game:GetService("Lighting").FogStart = S
            end
        end}
)
N:AddSlider(
    {Name = "Fog End", Min = 0, Max = 1000, Value = df.FogEnd or 100, Callback = function(S)
            df.FogEnd = S
            if dj then
                game:GetService("Lighting").FogEnd = S
            end
        end}
)
N:AddColorpicker(
    {Name = "Atmo color", Value = dg, Callback = function(dq, dr)
            dg = dq
            if af then
                local dl = game:GetService("Lighting")
                dl.Ambient = dg
                dl.OutdoorAmbient = dg
                dl.FogColor = dg
                for X, ay in ipairs(workspace:GetDescendants()) do
                    if ay:IsA("BasePart") then
                        ay.Color = dg
                    end
                end
            end
        end}
)
N:AddColorpicker(
    {Name = "Sword color", Value = dh, Callback = function(dq, dr)
            dh = dq
            if af then
                game:GetService("Workspace").Camera.Viewmodel.WoodenSword.MainPart.Mesh.VertexColor =
                    Vector3.new(dh.r, dh.g, dh.b)
            end
        end}
)
local ds, dt = 1, false
getgenv().res = ds
N:AddToggle(
    {Name = "ress", Callback = function(dn)
            dt = dn
            if dn then
                while dt do
                    game:GetService("RunService").RenderStepped:Wait()
                    j.CFrame = j.CFrame * CFrame.new(0, 0, 0, 1, 0, 0, 0, getgenv().res, 0, 0, 0, 1)
                end
            end
        end}
)
N:AddSlider(
    {Name = "Resolution", Min = 0, Max = 1.2, Precise = 2, Value = ds, Callback = function(S)
            getgenv().res = S
        end}
)
local du, dv, dw, dx, dy = 0.5, Color3.fromRGB(200, 150, 255), false, false, false
local function dz(dA)
    return Color3.new(dA.r, dA.g, dA.b)
end
local function dB(a4)
    local dA = a4.TeamColor
    local dB = Instance.new("Highlight")
    dB.Name = a4.Name
    dB.FillColor = dv
    dB.DepthMode = "AlwaysOnTop"
    dB.FillTransparency = du
    dB.OutlineTransparency = du
    dB.Parent = Storage
    local dC = a4.Character
    if dC then
        dB.Adornee = dC
    end
    a4.CharacterAdded:Connect(
        function(dD)
            dB.Adornee = dD
        end
    )
    a4:GetPropertyChangedSignal("Team"):Connect(
        function()
            local dE = a4.TeamColor
            dB.FillColor = dz(dE)
        end
    )
end
local function dF()
    for X, Y in ipairs(game.Players:GetPlayers()) do
        if Y == game.Players.LocalPlayer then
            if dw then
                if not Storage:FindFirstChild(Y.Name) then
                    dB(Y)
                end
            else
                local dG = Storage:FindFirstChild(Y.Name)
                if dG then
                    dG:Destroy()
                end
            end
        else
            if not Storage:FindFirstChild(Y.Name) then
                dB(Y)
            end
        end
    end
end
local function dH(af)
    if af then
        dy = true
        local dI = game:GetService("CoreGui")
        local b = game:GetService("Players")
        Storage = Instance.new("Folder")
        Storage.Parent = dI
        Storage.Name = "Highlight_Storage"
        dF()
        coroutine.wrap(
            function()
                while dy do
                    task.wait(0.15)
                    dF()
                end
            end
        )()
    else
        dy = false
        local Storage = game.CoreGui:FindFirstChild("Highlight_Storage")
        if Storage then
            for X, dJ in ipairs(Storage:GetChildren()) do
                dJ:Destroy()
            end
            Storage:Destroy()
        end
    end
end
local function dK(af)
    dw = af
    dF()
end
local function dL(af)
    dx = af
    dF()
end
local function dM(dq)
    dv = dq
    local Storage = game.CoreGui:FindFirstChild("Highlight_Storage")
    if Storage then
        for X, dJ in ipairs(Storage:GetChildren()) do
            dJ.FillColor = dq
        end
    end
end
L:AddToggle(
    {Name = "chams", Value = false, Callback = function(af)
            dH(af)
        end}
)
L:AddColorpicker(
    {Name = "Color", Value = dv, Callback = function(dq, dr)
            dM(dq)
        end}
)
L:AddToggle({Name = "Self", Value = false, Callback = dK})
L:AddSlider(
    {Name = "Transparency", Min = 0, Max = 1, Value = du, Callback = function(S)
            du = S
            local Storage = game.CoreGui:FindFirstChild("Highlight_Storage")
            if Storage then
                for X, dJ in ipairs(Storage:GetChildren()) do
                    dJ.FillTransparency = S
                    dJ.OutlineTransparency = S
                end
            end
        end}
)
L:AddToggle(
    {
        Name = "Cape",
        Value = false,
        Callback = function(S)
            local Y = game.Players.LocalPlayer
            local Z = Y.Character
            local function dN()
                local aL = Z:WaitForChild("Humanoid")
                local dO =
                    aL.RigType == Enum.HumanoidRigType.R15 and Z:WaitForChild("UpperTorso") or Z:WaitForChild("Torso")
                local dP = Instance.new("Part", Z)
                dP.Name = "Cape"
                dP.Anchored = false
                dP.CanCollide = false
                dP.TopSurface = Enum.SurfaceType.Smooth
                dP.BottomSurface = Enum.SurfaceType.Smooth
                dP.Size = Vector3.new(0.2, 0.2, 0.2)
                dP.Transparency = 0
                dP.BrickColor = BrickColor.new("Really black")
                local dQ = Instance.new("BlockMesh", dP)
                dQ.Scale = Vector3.new(9, 17.5, 0.08)
                local dR = Instance.new("Motor", dP)
                dR.Part0 = dP
                dR.Part1 = dO
                dR.MaxVelocity = 0.01
                dR.C0 = CFrame.new(0, 2, 0) * CFrame.Angles(0, math.rad(90), 0)
                dR.C1 = CFrame.new(0, 1, 0.45) * CFrame.Angles(0, math.rad(90), 0)
                spawn(
                    function()
                        local dS = false
                        while dP.Parent == Z do
                            task.wait(1 / 60)
                            local b4 = 0.1
                            local dT = dO.Velocity.Magnitude
                            if dS then
                                b4 = b4 + dO.Velocity.Magnitude / 10 * 0.05 + 0.05
                                dS = false
                            else
                                dS = true
                            end
                            b4 = b4 + math.min(dO.Velocity.Magnitude / 11, 0.5)
                            dR.MaxVelocity = math.min(dO.Velocity.Magnitude / 111, 0.04)
                            dR.DesiredAngle = -b4
                            if dR.CurrentAngle < -0.2 and dR.DesiredAngle > -0.2 then
                                dR.MaxVelocity = 0.04
                            end
                            repeat
                                task.wait()
                            until dR.CurrentAngle == dR.DesiredAngle or
                                math.abs(dO.Velocity.Magnitude - dT) >= dO.Velocity.Magnitude / 10 + 1
                            if dO.Velocity.Magnitude < 0.1 then
                                task.wait(0.1)
                            end
                        end
                    end
                )
            end
            local function dU()
                local dP = Z:FindFirstChild("Cape")
                if dP then
                    dP:Destroy()
                end
            end
            if S then
                if not Z:FindFirstChild("Cape") then
                    dN()
                end
            else
                dU()
            end
        end
    }
)
local dV = {
    {Name = "Mouse", Value = "Mouse"},
    {Name = "Bottom Center", Value = "BottomCenter"},
    {Name = "Top Center", Value = "TopCenter"},
    {Name = "Left Center", Value = "LeftCenter"},
    {Name = "Right Center", Value = "RightCenter"}
}
local dW = 1
L:AddDropdown(
    {
        Name = "Tracer Source",
        Default = dV[dW].Name,
        List = {dV[1].Name, dV[2].Name, dV[3].Name, dV[4].Name, dV[5].Name},
        Callback = function(S)
            for dX, dY in ipairs(dV) do
                if dY.Name == S then
                    dW = dX
                    break
                end
            end
        end
    }
)
L:AddToggle(
    {
        Name = "Tracer",
        Value = false,
        Callback = function(af)
            Tracer = af
            local e = game:GetService("RunService")
            local b = game:GetService("Players")
            local dZ = game:GetService("Workspace")
            local d_ = game:GetService("UserInputService")
            local j = dZ.CurrentCamera
            local settings = {
                DefaultSettings = false,
                TeamCheck = false,
                TracersVisible = true,
                TracerColor = Color3.fromRGB(128, 0, 128),
                TracerThickness = 1.8,
                TracerTransparency = 0.8
            }
            local e0 = {}
            local function e1(Z)
                local cS = Drawing.new("Line")
                cS.Thickness = settings.TracerThickness
                cS.Transparency = settings.TracerTransparency
                cS.Visible = false
                cS.Color = settings.TracerColor
                local function e2()
                    if not Z:IsDescendantOf(dZ) or not Z:FindFirstChild("HumanoidRootPart") then
                        cS.Visible = false
                        return
                    end
                    local e3 = Z:FindFirstChild("Head") or Z:FindFirstChild("HumanoidRootPart")
                    if not e3 then
                        cS.Visible = false
                        return
                    end
                    local e4 = e3.Position
                    local e5, e6 = j:WorldToViewportPoint(e4)
                    local e7 = dV[dW]
                    if e7.Value == "Mouse" then
                        cS.From = Vector2.new(d_:GetMouseLocation().X, d_:GetMouseLocation().Y)
                    elseif e7.Value == "BottomCenter" then
                        cS.From = Vector2.new(j.ViewportSize.X / 2, j.ViewportSize.Y)
                    elseif e7.Value == "TopCenter" then
                        cS.From = Vector2.new(j.ViewportSize.X / 2, 0)
                    elseif e7.Value == "LeftCenter" then
                        cS.From = Vector2.new(0, j.ViewportSize.Y / 2)
                    elseif e7.Value == "RightCenter" then
                        cS.From = Vector2.new(j.ViewportSize.X, j.ViewportSize.Y / 2)
                    end
                    if e6 then
                        cS.To = Vector2.new(e5.X, e5.Y)
                        if settings.TeamCheck then
                            cS.Visible = b.LocalPlayer.Team ~= Z.Team
                        else
                            cS.Visible = Tracer
                        end
                    else
                        cS.Visible = false
                    end
                end
                e0[Z] = cS
                return cS, e2
            end
            local function e8(Y, Z)
                if Y == b.LocalPlayer then
                    return
                end
                if not Z or not Z:IsDescendantOf(dZ) or not Z:FindFirstChild("HumanoidRootPart") then
                    return
                end
                local e9, ea = e1(Z)
                e.RenderStepped:Connect(
                    function()
                        ea()
                    end
                )
                Z.AncestryChanged:Connect(
                    function()
                        if not Z:IsDescendantOf(dZ) then
                            e9.Visible = false
                            e0[Z] = nil
                        end
                    end
                )
            end
            b.PlayerAdded:Connect(
                function(Y)
                    Y.CharacterAdded:Connect(
                        function(Z)
                            e8(Y, Z)
                        end
                    )
                end
            )
            for X, Y in ipairs(b:GetPlayers()) do
                e8(Y, Y.Character)
            end
            d_.InputBegan:Connect(
                function(c7)
                    if c7.KeyCode == settings.ModeSkipKey and not d_:GetFocusedTextBox() then
                        dW = dW % #dV + 1
                        for X, cS in pairs(e0) do
                            cS.Visible = settings.TracersVisible and Tracer
                        end
                    elseif c7.KeyCode == settings.DisableKey and not d_:GetFocusedTextBox() then
                        settings.TracersVisible = not settings.TracersVisible
                        for X, cS in pairs(e0) do
                            cS.Visible = settings.TracersVisible and Tracer
                        end
                    end
                end
            )
            if settings.DefaultSettings then
                settings.TeamCheck = false
                settings.TracersVisible = true
                settings.TracerColor = Color3.fromRGB(128, 0, 128)
                settings.TracerThickness = 1.8
                settings.TracerTransparency = 0.8
            end
        end
    }
)
local Y, eb = game.Players.LocalPlayer, false
local function ec(Z)
    local e3 = Z:FindFirstChild("Head")
    if e3 then
        local ed = e3:FindFirstChild("face")
        if ed then
            ed:Destroy()
        end
    end
end
local function ee(ay)
    if ay:IsA("Accessory") or ay:IsA("Shirt") or ay:IsA("Pants") or ay.Name == "Face" then
        ay:Destroy()
    elseif ay:IsA("BasePart") then
        ay.Material = Enum.Material.ForceField
        ay.Color = Color3.fromRGB(225, 160, 255)
    end
end
local function ef(Z)
    ec(Z)
    for X, ay in ipairs(Z:GetChildren()) do
        ee(ay)
    end
    Z.ChildAdded:Connect(ee)
end
local function eg(Z)
    task.wait(0.14)
    if eb then
        ef(Z)
    end
end
L:AddToggle(
    {Name = "Self visual", Value = false, Callback = function(dn)
            eb = dn
            if dn then
                eg(Y.Character or Y.CharacterAdded:Wait())
            end
        end}
)
Y.CharacterAdded:Connect(eg)
